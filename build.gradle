//version: 1685501596
/*
 * DO NOT CHANGE THIS FILE!
 * Also, you may replace this file at any time if there is an update available.
 * Please check https://github.com/GregTechCEu/Buildscripts/blob/master/build.gradle for updates.
 */

import com.modrinth.minotaur.dependencies.ModDependency
import com.modrinth.minotaur.dependencies.VersionDependency
import org.gradle.api.tasks.testing.logging.TestExceptionFormat
import org.gradle.api.tasks.testing.logging.TestLogEvent
import org.gradle.internal.logging.text.StyledTextOutputFactory
import org.jetbrains.gradle.ext.Gradle

import static org.gradle.internal.logging.text.StyledTextOutput.Style

plugins {
    id 'java'
    id 'java-library'
    id 'eclipse'
    id 'org.jetbrains.gradle.plugin.idea-ext' version '1.1.7'
    id 'com.gtnewhorizons.retrofuturagradle' version '1.3.+'
    id 'net.darkhax.curseforgegradle' version '1.0.+' apply false
    id 'com.modrinth.minotaur' version '2.7.+' apply false
    id 'com.diffplug.spotless' version '6.13.0' apply false
    id 'com.palantir.git-version' version '3.0.0' apply false
}

if (verifySettingsGradle()) {
    throw new GradleException("Settings has been updated, please re-run task.")
}

def out = services.get(StyledTextOutputFactory).create('an-output')


// Project properties

// Required properties: we don't know how to handle these being missing gracefully
checkPropertyExists("modName")
checkPropertyExists("modId")
checkPropertyExists("modGroup")
checkPropertyExists("modVersion")
checkPropertyExists("minecraftVersion") // hard-coding this makes it harder to immediately tell what version a mod is in (even though this only really supports 1.12.2)
checkPropertyExists("apiPackage")
checkPropertyExists("accessTransformersFile")
checkPropertyExists("usesMixins")
checkPropertyExists("mixinsPackage")
checkPropertyExists("coreModClass")
checkPropertyExists("containsMixinsAndOrCoreModOnly")

// Optional properties: we can assume some default behavior if these are missing
propertyDefaultIfUnset("autoUpdateBuildScript", false)
propertyDefaultIfUnset("modArchivesBaseName", project.modId)
propertyDefaultIfUnsetWithEnvVar("developmentEnvironmentUserName", "Developer", "DEV_USERNAME")
propertyDefaultIfUnset("generateGradleTokenClass", "")
propertyDefaultIfUnset("gradleTokenModId", "")
propertyDefaultIfUnset("gradleTokenModName", "")
propertyDefaultIfUnset("gradleTokenVersion", "")
propertyDefaultIfUnset("includeWellKnownRepositories", true)
propertyDefaultIfUnset("includeCommonDevEnvMods", true)
propertyDefaultIfUnset("noPublishedSources", false)
propertyDefaultIfUnset("forceEnableMixins", false)
propertyDefaultIfUnset("modrinthProjectId", "")
propertyDefaultIfUnset("modrinthRelations", "")
propertyDefaultIfUnset("curseForgeProjectId", "")
propertyDefaultIfUnset("curseForgeRelations", "")
propertyDefaultIfUnset("releaseType", "release")
propertyDefaultIfUnset("enableModernJavaSyntax", false)
propertyDefaultIfUnset("enableSpotless", false)
propertyDefaultIfUnset("enableJUnit", false)
propertyDefaultIfUnsetWithEnvVar("deploymentDebug", false, "DEPLOYMENT_DEBUG")


// Project property assertions

final String javaSourceDir = 'src/main/java/'
// If Scala or Kotlin are supported, add those paths here

final String modGroupPath = modGroup.toString().replace('.' as char, '/' as char)
final String apiPackagePath = apiPackage.toString().replace('.' as char, '/' as char)

String targetPackageJava = javaSourceDir + modGroupPath
// If Scala or Kotlin are supported, add those paths here

if (!getFile(targetPackageJava).exists()) {
    throw new GradleException("Could not resolve \"modGroup\"! Could not find " + targetPackageJava)
}

if (apiPackage) {
    targetPackageJava = javaSourceDir + modGroupPath + '/' + apiPackagePath
    if (!getFile(targetPackageJava).exists()) {
        throw new GradleException("Could not resolve \"apiPackage\"! Could not find " + targetPackageJava)
    }
}

if (accessTransformersFile) {
    for (atFile in accessTransformersFile.split(",")) {
        String targetFile = 'src/main/resources/' + atFile.trim()
        if (!getFile(targetFile).exists()) {
            throw new GradleException("Could not resolve \"accessTransformersFile\"! Could not find " + targetFile)
        }
        tasks.deobfuscateMergedJarToSrg.accessTransformerFiles.from(targetFile)
        tasks.srgifyBinpatchedJar.accessTransformerFiles.from(targetFile)
    }
}

if (usesMixins.toBoolean()) {
    if (mixinsPackage.isEmpty()) {
        throw new GradleException("\"usesMixins\" requires \"mixinsPackage\" to be set!")
    }
    final String mixinPackagePath = mixinsPackage.toString().replaceAll('\\.', '/')
    targetPackageJava = javaSourceDir + modGroupPath + '/' + mixinPackagePath
    if (!getFile(targetPackageJava).exists()) {
        throw new GradleException("Could not resolve \"mixinsPackage\"! Could not find " + targetPackageJava)
    }
}

if (coreModClass) {
    final String coreModPath = coreModClass.toString().replaceAll('\\.', '/')
    String targetFileJava = javaSourceDir + modGroupPath + '/' + coreModPath + '.java'
    if (!getFile(targetFileJava).exists()) {
        throw new GradleException("Could not resolve \"coreModClass\"! Could not find " + targetFileJava)
    }
}


// Plugin application

// Spotless
//noinspection GroovyAssignabilityCheck
project.extensions.add(com.diffplug.blowdryer.Blowdryer, 'Blowdryer', com.diffplug.blowdryer.Blowdryer) // make Blowdryer available in plugin application
if (enableSpotless.toBoolean()) {
    apply plugin: 'com.diffplug.spotless'

    // Spotless auto-formatter
    // See https://github.com/diffplug/spotless/tree/main/plugin-gradle
    // Can be locally toggled via spotless:off/spotless:on comments
    spotless {
        encoding 'UTF-8'

        format 'misc', {
            target '.gitignore'

            trimTrailingWhitespace()
            indentWithSpaces(4)
            endWithNewline()
        }
        java {
            target 'src/main/java/**/*.java', 'src/test/java/**/*.java' // exclude api as they are not our files

            def orderFile = project.file('spotless.importorder')
            if (!orderFile.exists()) {
                orderFile = Blowdryer.file('spotless.importorder')
            }
            def formatFile = project.file('spotless.eclipseformat.xml')
            if (!formatFile.exists()) {
                formatFile = Blowdryer.file('spotless.eclipseformat.xml')
            }

            toggleOffOn()
            importOrderFile(orderFile)
            removeUnusedImports()
            endWithNewline()
            //noinspection GroovyAssignabilityCheck
            eclipse('4.19.0').configFile(formatFile)
        }
    }
}

// Git submodules
if (project.file('.git/HEAD').isFile() || project.file('.git').isFile()) {
    apply plugin: 'com.palantir.git-version'
}


// Configure Java

java {
    toolchain {
        if (enableModernJavaSyntax.toBoolean()) {
            languageVersion.set(JavaLanguageVersion.of(17))
        } else {
            languageVersion.set(JavaLanguageVersion.of(8))
        }
        // Azul covers the most platforms for Java 8+ toolchains, crucially including MacOS arm64
        vendor.set(JvmVendorSpec.AZUL)
    }
    if (!noPublishedSources.toBoolean()) {
        withSourcesJar()
    }
}

tasks.withType(JavaCompile).configureEach {
    options.encoding = 'UTF-8'

    if (enableModernJavaSyntax.toBoolean()) {
        if (it.name in ['compileMcLauncherJava', 'compilePatchedMcJava']) {
            return
        }

        sourceCompatibility = 17
        options.release.set(8)

        javaCompiler.set(javaToolchains.compilerFor {
            languageVersion.set(JavaLanguageVersion.of(17))
            vendor.set(JvmVendorSpec.AZUL)
        })
    }
}


// Configure Minecraft

version = modVersion
group = modGroup
archivesBaseName = modArchivesBaseName

minecraft {
    mcVersion = minecraftVersion
    username = developmentEnvironmentUserName.toString()
    useDependencyAccessTransformers = true

    // Automatic token injection with RetroFuturaGradle
    if (gradleTokenModId) {
        injectedTags.put gradleTokenModId, modId
    }
    if (gradleTokenModName) {
        injectedTags.put gradleTokenModName, modName
    }
    if (gradleTokenVersion) {
        injectedTags.put gradleTokenVersion, modVersion
    }

    // JVM arguments
    extraRunJvmArguments.add("-ea:${modGroup}")
    if (usesMixins.toBoolean()) {
        extraRunJvmArguments.addAll([
            '-Dmixin.hotSwap=true',
            '-Dmixin.checks.interfaces=true',
            '-Dmixin.debug.export=true'
        ])
    }
    if (coreModClass) {
        extraRunJvmArguments.add("-Dfml.coreMods.load=${modGroup}.${coreModClass}")
    }
}

if (generateGradleTokenClass) {
    tasks.injectTags.outputClassName.set(generateGradleTokenClass)
}

tasks.named('processIdeaSettings').configure {
    dependsOn('injectTags')
}


// Allow others using this buildscript to have custom gradle code run
if (getFile('addon.gradle').exists()) {
    apply from: 'addon.gradle'
}


// Repositories

// Allow unsafe repos but warn
repositories.configureEach { repo ->
    if (repo instanceof UrlArtifactRepository) {
        if (repo.getUrl() != null && repo.getUrl().getScheme() == "http" && !repo.allowInsecureProtocol) {
            logger.warn("Deprecated: Allowing insecure connections for repo '${repo.name}' - add 'allowInsecureProtocol = true'")
            repo.allowInsecureProtocol = true
        }
    }
}

// Allow adding custom repositories to the buildscript
if (getFile('repositories.gradle').exists()) {
    apply from: 'repositories.gradle'
}

repositories {
    if (includeWellKnownRepositories.toBoolean() || includeCommonDevEnvMods.toBoolean()) {
        exclusiveContent {
            forRepository {
                //noinspection ForeignDelegate
                maven {
                    name = 'Curse Maven'
                    url = 'https://www.cursemaven.com'
                }
            }
            filter {
                includeGroup 'curse.maven'
            }
        }
        exclusiveContent {
            forRepository {
                //noinspection ForeignDelegate
                maven {
                    name = 'Modrinth'
                    url = 'https://api.modrinth.com/maven'
                }
            }
            filter {
                includeGroup 'maven.modrinth'
            }
        }
        maven {
            name 'Cleanroom Maven'
            url 'https://maven.cleanroommc.com'
        }
        maven {
            name 'BlameJared Maven'
            url 'https://maven.blamejared.com'
        }
    }
    if (usesMixins.toBoolean() || forceEnableMixins.toBoolean()) {
        maven {
            name 'Sponge Maven'
            url 'https://repo.spongepowered.org/maven'
        }
        // need to add this here even if we did not above
        if (!includeWellKnownRepositories.toBoolean()) {
            maven {
                name 'Cleanroom Maven'
                url 'https://maven.cleanroommc.com'
            }
        }
    }
    mavenLocal() // Must be last for caching to work
}


// Dependencies

// Configure dependency configurations
configurations {
    embed
    implementation.extendsFrom(embed)
}

dependencies {
    if (usesMixins.toBoolean() || forceEnableMixins.toBoolean()) {
        implementation 'zone.rong:mixinbooter:7.0'
        api('org.spongepowered:mixin:0.8.3') {
            transitive = false
        }
        annotationProcessor('org.spongepowered:mixin:0.8.3') {
            transitive = false
        }

        annotationProcessor 'org.ow2.asm:asm-debug-all:5.2'
        // should use 24.1.1 but 30.0+ has a vulnerability fix
        annotationProcessor 'com.google.guava:guava:30.0-jre'
        // should use 2.8.6 but 2.8.9+ has a vulnerability fix
        annotationProcessor 'com.google.code.gson:gson:2.8.9'
    }

    if (enableJUnit.toBoolean()) {
        testImplementation 'org.junit.jupiter:junit-jupiter:5.9.1'
        testImplementation 'org.hamcrest:hamcrest:2.2'
    }

    if (enableModernJavaSyntax.toBoolean()) {
        annotationProcessor 'com.github.bsideup.jabel:jabel-javac-plugin:1.0.0'
        compileOnly('com.github.bsideup.jabel:jabel-javac-plugin:1.0.0') {
            transitive = false
        }
        // workaround for https://github.com/bsideup/jabel/issues/174
        annotationProcessor 'net.java.dev.jna:jna-platform:5.13.0'
        // Allow jdk.unsupported classes like sun.misc.Unsafe, workaround for JDK-8206937 and fixes Forge crashes in tests.
        patchedMinecraft 'me.eigenraven.java8unsupported:java-8-unsupported-shim:1.0.0'

        // allow Jabel to work in tests
        testAnnotationProcessor "com.github.bsideup.jabel:jabel-javac-plugin:1.0.0"
        testCompileOnly("com.github.bsideup.jabel:jabel-javac-plugin:1.0.0") {
            transitive = false // We only care about the 1 annotation class
        }
        testCompileOnly "me.eigenraven.java8unsupported:java-8-unsupported-shim:1.0.0"
    }

    compileOnlyApi 'org.jetbrains:annotations:23.0.0'
    annotationProcessor 'org.jetbrains:annotations:23.0.0'

    if (includeCommonDevEnvMods.toBoolean()) {
        implementation 'mezz.jei:jei_1.12.2:4.16.1.302'
        //noinspection DependencyNotationArgument
        implementation rfg.deobf('curse.maven:top-245211:2667280') // TOP 1.4.28
    }
}

if (getFile('dependencies.gradle').exists()) {
    apply from: 'dependencies.gradle'
}


// Test configuration

// Ensure tests have access to minecraft classes
sourceSets {
    test {
        java {
            compileClasspath += patchedMc.output + mcLauncher.output
            runtimeClasspath += patchedMc.output + mcLauncher.output
        }
    }
}

test {
    // ensure tests are run with java8
    javaLauncher = javaToolchains.launcherFor {
        languageVersion = JavaLanguageVersion.of(8)
    }.get()

    testLogging {
        events TestLogEvent.STARTED, TestLogEvent.PASSED, TestLogEvent.FAILED
        exceptionFormat TestExceptionFormat.FULL
        showExceptions true
        showStackTraces true
        showCauses true
        showStandardStreams true
    }

    if (enableJUnit.toBoolean()) {
        useJUnitPlatform()
    }
}


// Resource processing and jar building

processResources {
    // this will ensure that this task is redone when the versions change.
    inputs.property 'version', modVersion
    inputs.property 'mcversion', minecraftVersion
    // Blowdryer puts these files into the resource directory, so
    // exclude them from builds (doesn't hurt to exclude even if not present)
    exclude('spotless.importorder')
    exclude('spotless.eclipseformat.xml')

    // replace stuff in mcmod.info, nothing else
    filesMatching(['mcmod.info', 'pack.mcmeta']) { fcd ->
        // replace version and mcversion
        fcd.expand(
                'version': modVersion,
                'mcversion': minecraftVersion
        )
    }
}

// Automatically generate a mixin json file if it does not already exist
tasks.register('generateAssets') {
    group = 'GT Buildscript'
    description = 'Generates a mixin config file at /src/main/resources/mixins.modid.json if needed'
    onlyIf {
        usesMixins.toBoolean()
    }
    doLast {
        def mixinConfigFile = getFile("src/main/resources/mixins.${modId}.json")
        if (!mixinConfigFile.exists()) {
            def mixinConfigRefmap = "mixins.${modId}.refmap.json"

            mixinConfigFile.text = """{
  "package": "${modGroup}.${mixinsPackage}",
  "refmap": "${mixinConfigRefmap}",
  "target": "@env(DEFAULT)",
  "minVersion": "0.8",
  "compatibilityLevel": "JAVA_8",
  "mixins": [],
  "client": [],
  "server": []
}
"""
        }
    }
}

if (usesMixins.toBoolean()) {
    tasks.named('processResources').configure {
        dependsOn('generateAssets')
    }
}

jar {
    manifest {
        def attribute_map = [:]
        if (coreModClass) {
            attribute_map['FMLCorePlugin'] = "${modGroup}.${coreModClass}"
        }
        if (!containsMixinsAndOrCoreModOnly.toBoolean() && (usesMixins.toBoolean() || coreModClass)) {
            attribute_map['FMLCorePluginContainsFMLMod'] = true
        }
        if (accessTransformersFile) {
            attribute_map['FMLAT'] = accessTransformersFile.toString()
        }

        if (usesMixins.toBoolean()) {
            attribute_map['ForceLoadAsMod'] = !containsMixinsAndOrCoreModOnly.toBoolean()
        }
        attributes(attribute_map)
    }

    // Add all embedded dependencies into the jar
    from provider {
        configurations.embed.collect {
            it.isDirectory() ? it : zipTree(it)
        }
    }
}

// Create API library jar
tasks.register('apiJar', Jar) {
    archiveClassifier.set 'api'
    from(sourceSets.main.java) {
        include "${modGroupPath}/${apiPackagePath}/**"
    }

    from(sourceSets.main.output) {
        include "${modGroupPath}/${apiPackagePath}/**"
    }
}


// IDE Configuration

eclipse {
    classpath {
        downloadSources = true
        downloadJavadoc = true
    }
}

idea {
    module {
        inheritOutputDirs true
        downloadJavadoc true
        downloadSources true
    }
    project {
        settings {
            runConfigurations {
                '1. Run Client'(Gradle) {
                    taskNames = ['runClient']
                }
                '2. Run Server'(Gradle) {
                    taskNames = ['runServer']
                }
                '3. Run Obfuscated Client'(Gradle) {
                    taskNames = ['runObfClient']
                }
                '4. Run Obfuscated Server'(Gradle) {
                    taskNames = ['runObfServer']
                }
                if (enableSpotless.toBoolean()) {
                    "5. Apply Spotless"(Gradle) {
                        taskNames = ["spotlessApply"]
                    }
                }
                'Update Buildscript'(Gradle) {
                    taskNames = ['updateBuildScript']
                }
                'FAQ'(Gradle) {
                    taskNames = ['faq']
                }
            }
            compiler.javac {
                afterEvaluate {
                    javacAdditionalOptions = '-encoding utf8'
                    moduleJavacAdditionalOptions = [
                            (project.name + '.main'): tasks.compileJava.options.compilerArgs.collect {
                                '"' + it + '"'
                            }.join(' ')
                    ]
                }
            }
        }
    }
}


// Deployment

final boolean isCIEnv = providers.environmentVariable('CI').getOrElse('false').toBoolean()
def final changelogEnv = providers.environmentVariable('CHANGELOG_LOCATION')
File changelogFile = new File(changelogEnv.getOrElse('CHANGELOG.md'))

if (isCIEnv || deploymentDebug.toBoolean()) {
    artifacts {
        if (!noPublishedSources.toBoolean()) {
            archives sourcesJar
        }
        if (apiPackage) {
            archives apiJar
        }
    }
}

// Curseforge
def final cfApiKey = providers.environmentVariable('CURSEFORGE_API_KEY')
if (cfApiKey.isPresent() || deploymentDebug.toBoolean()) {
    apply plugin: 'net.darkhax.curseforgegradle'
    //noinspection UnnecessaryQualifiedReference
    tasks.register('curseforge', net.darkhax.curseforgegradle.TaskPublishCurseForge) {
        apiToken = cfApiKey.get()
        def projectIdVar = providers.environmentVariable('CURSEFORGE_PROJECT_ID')

        def mainFile = upload(projectIdVar.getOrElse(curseForgeProjectId), reobfJar)
        def changelogRaw = changelogFile.exists() ? changelogFile.getText('UTF-8') : ""

        mainFile.releaseType = getReleaseType()
        mainFile.changelog = changelogRaw
        mainFile.changelogType = 'markdown'
        mainFile.addModLoader 'Forge'
        mainFile.addJavaVersion "Java 8"
        mainFile.addGameVersion minecraftVersion

        if (curseForgeRelations.size() != 0) {
            String[] deps = curseForgeRelations.split(';')
            deps.each { dep ->
                if (dep.size() == 0) {
                    return
                }
                String parts = dep.split(':')
                String type = parts[0], slug = parts[1]
                if(!(type in ['requiredDependency', 'embeddedLibrary', 'optionalDependency', 'tool', 'incompatible'])) {
                    throw new Exception('Invalid Curseforge dependency type: ' + type)
                }
                mainFile.addRelation(slug, type)
            }
        }

        for (artifact in getSecondaryArtifacts()) {
            def additionalFile = mainFile.withAdditionalFile(artifact)
            additionalFile.changelog = changelogRaw
        }
        disableVersionDetection()
        debugMode = deploymentDebug.toBoolean()
    }
    tasks.curseforge.dependsOn(build)
}

// Modrinth
def final modrinthApiKey = providers.environmentVariable('MODRINTH_API_KEY')
if (modrinthApiKey.isPresent() || deploymentDebug.toBoolean()) {
    apply plugin: 'com.modrinth.minotaur'
    def final projectIdVar = providers.environmentVariable('MODRINTH_PROJECT_ID')

    modrinth {
        token = modrinthApiKey.get()
        projectId = projectIdVar.getOrElse(modrinthProjectId)
        changelog = changelogFile.exists() ? changelogFile.getText('UTF-8') : ""
        versionType = getReleaseType()
        versionNumber = modVersion
        gameVersions = [minecraftVersion]
        loaders = ["forge"]
        debugMode = deploymentDebug.toBoolean()
        uploadFile = file("build/libs/${archivesBaseName}-${version}.jar")
        additionalFiles = getSecondaryArtifacts()
    }
    if (modrinthRelations.size() != 0) {
        String[] deps = modrinthRelations.split(';')
        deps.each { dep ->
            if (dep.size() == 0) {
                return
            }
            String[] parts = dep.split(':')
            String qual = parts[0].split('-')
            addModrinthDep(qual[0], qual[1], parts[1])
        }
    }
    tasks.modrinth.dependsOn(build)
}

def addModrinthDep(String scope, String type, String name) {
    com.modrinth.minotaur.dependencies.Dependency dep
    if (!(scope in ['required', 'optional', 'incompatible', 'embedded'])) {
        throw new Exception('Invalid modrinth dependency scope: ' + scope)
    }
    switch (type) {
        case 'project':
            dep = new ModDependency(name, scope)
            break
        case 'version':
            dep = new VersionDependency(name, scope)
            break
        default:
            throw new Exception('Invalid modrinth dependency type: ' + type)
    }
    project.modrinth.dependencies.add(dep)
}


// Buildscript updating

def buildscriptGradleVersion = '8.1.1'

tasks.named('wrapper', Wrapper).configure {
    gradleVersion = buildscriptGradleVersion
}

tasks.register('updateBuildScript') {
    group = 'GT Buildscript'
    description = 'Updates the build script to the latest version'

    if (gradle.gradleVersion != buildscriptGradleVersion && !Boolean.getBoolean('DISABLE_BUILDSCRIPT_GRADLE_UPDATE')) {
        dependsOn('wrapper')
    }

    doLast {
        if (performBuildScriptUpdate()) return
        print('Build script already up to date!')
    }
}

if (!project.getGradle().startParameter.isOffline() && !Boolean.getBoolean('DISABLE_BUILDSCRIPT_UPDATE_CHECK') && isNewBuildScriptVersionAvailable()) {
    if (autoUpdateBuildScript.toBoolean()) {
        performBuildScriptUpdate()
    } else {
        out.style(Style.SuccessHeader).println("Build script update available! Run 'gradle updateBuildScript'")
        if (gradle.gradleVersion != buildscriptGradleVersion) {
            out.style(Style.SuccessHeader).println("updateBuildScript can update gradle from ${gradle.gradleVersion} to ${buildscriptGradleVersion}\n")
        }
    }
}

static URL availableBuildScriptUrl() {
    new URL("https://raw.githubusercontent.com/GregTechCEu/Buildscripts/master/build.gradle")
}

static URL exampleSettingsGradleUrl() {
    new URL("https://raw.githubusercontent.com/GregTechCEu/Buildscripts/master/settings.gradle")
}

boolean verifySettingsGradle() {
    def settingsFile = getFile("settings.gradle")
    if (!settingsFile.exists()) {
        println("Downloading default settings.gradle")
        exampleSettingsGradleUrl().withInputStream { i -> settingsFile.withOutputStream { it << i } }
        return true
    }
    return false
}

boolean performBuildScriptUpdate() {
    if (isNewBuildScriptVersionAvailable()) {
        def buildscriptFile = getFile("build.gradle")
        availableBuildScriptUrl().withInputStream { i -> buildscriptFile.withOutputStream { it << i } }
        def out = services.get(StyledTextOutputFactory).create('buildscript-update-output')
        out.style(Style.Success).print("Build script updated. Please REIMPORT the project or RESTART your IDE!")
        if (verifySettingsGradle()) {
            throw new GradleException("Settings has been updated, please re-run task.")
        }
        return true
    }
    return false
}

boolean isNewBuildScriptVersionAvailable() {
    Map parameters = ["connectTimeout": 10000, "readTimeout": 10000]

    String currentBuildScript = getFile("build.gradle").getText()
    String currentBuildScriptHash = getVersionHash(currentBuildScript)
    String availableBuildScript = availableBuildScriptUrl().newInputStream(parameters).getText()
    String availableBuildScriptHash = getVersionHash(availableBuildScript)

    boolean isUpToDate = currentBuildScriptHash.empty || availableBuildScriptHash.empty || currentBuildScriptHash == availableBuildScriptHash
    return !isUpToDate
}

static String getVersionHash(String buildScriptContent) {
    String versionLine = buildScriptContent.find("^//version: [a-z0-9]*")
    if (versionLine != null) {
        return versionLine.split(": ").last()
    }
    return ""
}


// Faq

tasks.register('faq') {
    group = 'GT Buildscript'
    description = 'Prints frequently asked questions about building a project'
    doLast {
        print("\nTo update this buildscript to the latest version, run 'gradlew updateBuildScript' or run the generated run configuration if you are using IDEA.\n" +
                "To set up the project, run the 'setupDecompWorkspace' task, which you can run as './gradlew setupDecompWorkspace' in a terminal, or find in the 'modded minecraft' gradle category.\n\n" +
                "To add new dependencies to your project, place them in 'dependencies.gradle', NOT in 'build.gradle' as they would be replaced when the script updates.\n" +
                "To add new repositories to your project, place them in 'repositories.gradle'.\n" +
                "If you need additional gradle code to run, you can place it in a file named 'addon.gradle' (or either of the above, up to you for organization).\n\n" +
                "If your build fails to recognize the syntax of newer Java versions, enable Jabel in your 'gradle.properties' under the option name 'enableModernJavaSyntax'.\n" +
                "To see information on how to configure your IDE properly for Java 17, see https://github.com/GregTechCEu/Buildscripts/blob/master/jabel.md\n\n" +
                "Report any issues or feature requests you have for this build script to https://github.com/GregTechCEu/Buildscripts/issues\n")
    }
}


// Helpers

def getFile(String relativePath) {
    return new File(projectDir, relativePath)
}

def checkPropertyExists(String propertyName) {
    if (!project.hasProperty(propertyName)) {
        throw new GradleException("This project requires a property \"" + propertyName + "\"! Please add it your \"gradle.properties\". You can find all properties and their description here: https://github.com/GregTechCEu/Buildscripts/blob/main/gradle.properties")
    }
}

def propertyDefaultIfUnset(String propertyName, defaultValue) {
    if (!project.hasProperty(propertyName) || project.property(propertyName) == "") {
        project.ext.setProperty(propertyName, defaultValue)
    }
}

def propertyDefaultIfUnsetWithEnvVar(String propertyName, defaultValue, String envVarName) {
    def envVar = providers.environmentVariable(envVarName)
    if (envVar.isPresent()) {
        project.ext.setProperty(propertyName, envVar.get())
    } else {
        propertyDefaultIfUnset(propertyName, defaultValue)
    }
}

def getSecondaryArtifacts() {
    def secondaryArtifacts = [jar]
    if (!noPublishedSources.toBoolean()) secondaryArtifacts += [sourcesJar]
    if (apiPackage) secondaryArtifacts += [apiJar]
    return secondaryArtifacts
}

def getReleaseType() {
    String type = releaseType
    if (!(type in ['release', 'beta', 'alpha'])) {
        throw new Exception("Release type invalid! Found \"" + type + "\", allowed: \"release\", \"beta\", \"alpha\"")
    }
    return type
}
