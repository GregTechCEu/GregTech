//file:noinspection DependencyNotationArgument
// TODO remove when fixed in RFG ^

import org.gradle.api.tasks.testing.logging.TestExceptionFormat
import org.gradle.api.tasks.testing.logging.TestLogEvent
import org.jetbrains.gradle.ext.Gradle

plugins {
    id 'java'
    id 'java-library'
    id 'eclipse'
    id 'org.jetbrains.gradle.plugin.idea-ext' version "$idea_ext_version"
    id 'com.gtnewhorizons.retrofuturagradle' version "$rfg_version"
    id 'net.darkhax.curseforgegradle' version "$curseforge_gradle_version" apply false
    id 'com.modrinth.minotaur' version "$minotaur_version" apply false
}

version = project.mod_version
group = project.maven_group
archivesBaseName = project.archives_base_name

// Declare java compilation and java compatibility versions as groovy variables to prevent configuration errors when
// extracting values from the gradle.properties file
def javaVersion = project.java_version
def javaCompatVersion = project.java_compat_version

// Set the toolchain version to decouple the Java we run Gradle with from the Java used to compile and run the mod
java {
    toolchain {
        // Azul covers the most platforms for Java 8+ toolchains, crucially including MacOS arm64
        vendor.set(JvmVendorSpec.AZUL)
        languageVersion.set(JavaLanguageVersion.of(javaVersion))
    }

    // Generate sources when building and publishing
    withSourcesJar()
    // javadoc jar throws errors on incomplete docs
    // docs are also contained in the sources jar, so omit the javadoc-only jar
}

tasks.withType(JavaCompile).configureEach {
    // prevent compiling MC with newer java versions
    if (it.name in ['compileMcLauncherJava', 'compilePatchedMcJava']) {
        return
    }

    options.encoding 'UTF-8'

    // Enable Java17 for all other compilation tasks
    sourceCompatibility = javaVersion
    targetCompatibility = javaCompatVersion
    options.release.set(Integer.parseInt(javaCompatVersion))

    javaCompiler.set(javaToolchains.compilerFor {
        languageVersion.set(JavaLanguageVersion.of(javaVersion))
        vendor.set(JvmVendorSpec.AZUL)
    })
}

configurations {
    embed
    implementation.extendsFrom(embed)
}

minecraft {
    mcVersion = project.mc_version
    def args = [
            "-ea:${project.group}",
            "-Dfml.coreMods.load=${coremod_plugin_class_name}"
    ]
    extraRunJvmArguments.addAll(args)

    useDependencyAccessTransformers = true

    injectedTags.put('VERSION', project.version)
    injectedTags.put("DEP_VERSION_STRING", "required-after:gregtech@[" + project.version + ",);")
}

// Generate the InternalTags class with the version number as a field
tasks.injectTags.configure {
    outputClassName.set("${project.group}.GTInternalTags")
}

repositories {
    maven {
        // MixinBooter
        name 'Cleanroom Maven'
        url 'https://maven.cleanroommc.com'
    }
    maven {
        // CraftTweaker and JEI
        name 'BlameJared Maven'
        url 'https://maven.blamejared.com'
    }
    maven {
        // TOP, CTM, GRS, AE2
        name 'Curse Maven'
        url 'https://www.cursemaven.com'
        content {
            includeGroup 'curse.maven'
        }
    }
    maven {
        // Mixin
        name 'Sponge Maven'
        url 'https://repo.spongepowered.org/maven'
    }
    mavenLocal() // Must be last for caching to work
}

dependencies {
    // Hard Dependencies
    // the CCL deobf jar uses very old MCP mappings, making it error at runtime in runClient/runServer
    // therefore we manually deobf the regular jar
    implementation rfg.deobf("curse.maven:codechicken-lib-1-8-${ccl_pid}:${ccl_fid}")

    // Soft Dependencies
    implementation "mezz.jei:jei_1.12.2:${project.jei_version}"
    implementation "CraftTweaker2:CraftTweaker2-MC1120-Main:1.12-${project.crt_version}"
    implementation rfg.deobf("curse.maven:top-${top_pid}:${top_fid}")
    implementation rfg.deobf("curse.maven:ctm-${ctm_pid}:${ctm_fid}")

    // use a local jar for GroovyScript to avoid a bug from Mixin and ForgeGradle,
    // causing crashes at run-time when deobfuscated
    implementation files("libs/groovyscript-0.4.0.jar")
    //implementation fg.deobf("curse.maven:groovyscript-${grs_pid}:${grs_fid}")

    // Can change any of the below from compileOnlyApi -> implementation to test them in-game.
    // Left as compileOnlyApi by default for a slimmer default instance.
    compileOnlyApi rfg.deobf("curse.maven:ae2-extended-life-${ae2_pid}:${ae2_fid}")
    compileOnlyApi rfg.deobf("curse.maven:opencomputers-${oc_pid}:${oc_fid}")

    // Compile-Time Dependencies
    annotationProcessor "com.github.bsideup.jabel:jabel-javac-plugin:${jabel_version}"
    // workaround for https://github.com/bsideup/jabel/issues/174
    annotationProcessor "net.java.dev.jna:jna-platform:${jna_version}"
    compileOnly("com.github.bsideup.jabel:jabel-javac-plugin:${jabel_version}") {
        transitive = false // We only care about the 1 annotation class
    }
    // Allow jdk.unsupported classes like sun.misc.Unsafe, workaround for JDK-8206937 and fixes Forge crashes in tests.
    patchedMinecraft "me.eigenraven.java8unsupported:java-8-unsupported-shim:${unsupported_shim_version}"

    // Tests
    testImplementation "org.junit.jupiter:junit-jupiter:${junit_version}"
    testImplementation "org.hamcrest:hamcrest:${hamcrest_version}"

    // ae2 is a transitive dependency for MTE, so it's also needed at test-time
    testImplementation rfg.deobf("curse.maven:ae2-extended-life-${ae2_pid}:${ae2_fid}")

    // allow Jabel to work in tests
    testAnnotationProcessor "com.github.bsideup.jabel:jabel-javac-plugin:${jabel_version}"
    testCompileOnly("com.github.bsideup.jabel:jabel-javac-plugin:${jabel_version}") {
        transitive = false // We only care about the 1 annotation class
    }
    testCompileOnly "me.eigenraven.java8unsupported:java-8-unsupported-shim:${unsupported_shim_version}"

    // GroovyScript dependency
    implementation "zone.rong:mixinbooter:${mixinbooter_version}"

    // Mixin dependencies
    api("org.spongepowered:mixin:${mixin_version}") {
        transitive = false
    }
    annotationProcessor("org.spongepowered:mixin:${mixin_version}") {
        transitive = false
    }

    annotationProcessor "org.ow2.asm:asm-debug-all:${asm_debug_version}"
    annotationProcessor "com.google.guava:guava:${guava_version}-jre"
    annotationProcessor "com.google.code.gson:gson:${gson_version}"
}

//noinspection ConfigurationAvoidance
for (File at : sourceSets.getByName('main').resources.files) {
    if (at.name.toLowerCase().endsWith('_at.cfg')) {
        tasks.deobfuscateMergedJarToSrg.accessTransformerFiles.from at
        tasks.srgifyBinpatchedJar.accessTransformerFiles.from at
    }
}

processResources {
    // this will ensure that this task is redone when the versions change.
    inputs.property 'version', project.version
    inputs.property 'mcversion', project.minecraft.version
    // replace stuff in mcmod.info, nothing else
    filesMatching(['mcmod.info', 'pack.mcmeta']) { fcd ->
        // replace version and mcversion
        fcd.expand(
                'version': project.version,
                'mcversion': project.minecraft.version
        )
    }

    rename '(.+_at.cfg)', 'META-INF/$1' // Access Transformers
}

jar {
    manifest {
        def attribute_map = [:]
        attribute_map['FMLCorePlugin'] = coremod_plugin_class_name
        attribute_map['FMLCorePluginContainsFMLMod'] = true
        attribute_map['ForceLoadAsMod'] = project.gradle.startParameter.taskNames[0] == 'build'
        attribute_map['FMLAT'] = archives_base_name + '_at.cfg'
        attributes(attribute_map)
    }

    // Add all embedded dependencies into the jar
    from provider {
        configurations.embed.collect {
            it.isDirectory() ? it : zipTree(it)
        }
    }
}

test {
    // ensure tests are run with java8
    javaLauncher = javaToolchains.launcherFor {
        languageVersion = JavaLanguageVersion.of(javaCompatVersion)
    }.get()

    testLogging {
        events TestLogEvent.STARTED, TestLogEvent.PASSED, TestLogEvent.FAILED
        exceptionFormat TestExceptionFormat.FULL
        showExceptions true
        showStackTraces true
        showCauses true
        showStandardStreams true
    }

    useJUnitPlatform()
}

idea {
    module {
        inheritOutputDirs true
        downloadJavadoc true
        downloadSources true
    }
    project {
        settings {
            runConfigurations {
                '1. Run Client'(Gradle) {
                    taskNames = ['runClient']
                }
                '2. Run Server'(Gradle) {
                    taskNames = ['runServer']
                }
                '3. Run Obfuscated Client'(Gradle) {
                    taskNames = ['runObfClient']
                }
                '4. Run Obfuscated Server'(Gradle) {
                    taskNames = ['runObfServer']
                }
            }
            compiler.javac {
                afterEvaluate {
                    javacAdditionalOptions = '-encoding utf8'
                    moduleJavacAdditionalOptions = [
                            (project.name + '.main'): tasks.compileJava.options.compilerArgs.collect {
                                '"' + it + '"'
                            }.join(' ')
                    ]
                }
            }
        }
    }
}

// Create API library jar
tasks.register('apiJar', Jar) {
    archiveClassifier.set 'api'
    from(sourceSets.main.java) {
        include 'gregtech/api/**'
    }

    from(sourceSets.main.output) {
        include 'gregtech/api/**'
    }
}

sourceSets {
    test {
        java {
            compileClasspath += patchedMc.output + mcLauncher.output
            runtimeClasspath += patchedMc.output + mcLauncher.output
        }
    }
}

tasks.named('processIdeaSettings').configure {
    dependsOn('injectTags')
}

// Deployment

final boolean is_ci_env = providers.environmentVariable('CI').getOrElse('false').toBoolean()
final boolean deployment_debug = providers.environmentVariable('DEPLOYMENT_DEBUG').getOrElse("$deployment_debug").toBoolean()

if (is_ci_env || deployment_debug) {
    artifacts {
        archives jar
        archives apiJar
        archives sourcesJar
    }
}

def final cf_api_key = providers.environmentVariable('CURSEFORGE_API_KEY')
if (cf_api_key.isPresent() || deployment_debug) {
    apply plugin: 'net.darkhax.curseforgegradle'
    //noinspection UnnecessaryQualifiedReference
    tasks.register('curseforge', net.darkhax.curseforgegradle.TaskPublishCurseForge) {
        apiToken = cf_api_key.get()
        def final projectId = providers.environmentVariable('CURSEFORGE_PROJECT_ID').get()

        def mainFile = upload(projectId, reobfJar)
        mainFile.releaseType = providers.environmentVariable('RELEASE_TYPE').get()
        mainFile.changelog = providers.environmentVariable('CHANGELOG_LOCATION').get()
        mainFile.changelogType = 'markdown'
        mainFile.addRequirement 'codechicken-lib-1-8'
        mainFile.addIncompatibility 'gregtechce'
        mainFile.addModLoader 'Forge'
        mainFile.addJavaVersion "Java ${java_version}"
        mainFile.addGameVersion "$mc_version"

        def sourcesFile = mainFile.withAdditionalFile(sourcesJar)
        sourcesFile.changelog = providers.environmentVariable('CHANGELOG_LOCATION').get()

        def devFile = mainFile.withAdditionalFile(jar)
        devFile.changelog = providers.environmentVariable('CHANGELOG_LOCATION').get()

        disableVersionDetection()
    }

    tasks.curseforge.dependsOn(build)
}

def final modrinth_api_key = providers.environmentVariable('MODRINTH_API_KEY')
if (modrinth_api_key.isPresent() || deployment_debug) {
    apply plugin: 'com.modrinth.minotaur'

    modrinth {
        token = modrinth_api_key.get()
        projectId = providers.environmentVariable("MODRINTH_PROJECT_ID").get()
        changelog = providers.environmentVariable("CHANGELOG_LOCATION").get()
        versionType = providers.environmentVariable("RELEASE_TYPE").get()

        versionNumber = "$version".split('-')[0] // strip out the EXTRA field, if present
        gameVersions = ["$mc_version"]
        loaders = ["forge"]

        def main_artifact = "${archivesBaseName}-${version}.jar"
        uploadFile = file("build/libs/${main_artifact}")
        file('build/libs/').eachFile { file ->
            if (file.name.endsWith('.jar') && file.name != main_artifact) {
                additionalFiles.add file
            }
        }

        debugMode = deployment_debug
    }
    tasks.modrinth.dependsOn(build)
}
