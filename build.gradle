//version: 1685406033
//file:noinspection DependencyNotationArgument
// TODO remove when fixed in RFG ^

import com.diffplug.blowdryer.Blowdryer
import com.modrinth.minotaur.dependencies.ModDependency
import com.modrinth.minotaur.dependencies.VersionDependency
import org.gradle.api.tasks.testing.logging.TestExceptionFormat
import org.gradle.api.tasks.testing.logging.TestLogEvent
import org.gradle.internal.logging.text.StyledTextOutput.Style
import org.gradle.internal.logging.text.StyledTextOutputFactory
import org.jetbrains.gradle.ext.Gradle

plugins {
    id 'java'
    id 'java-library'
    id 'eclipse'
    id 'org.jetbrains.gradle.plugin.idea-ext' version '1.1.7'
    id 'com.gtnewhorizons.retrofuturagradle' version '1.3.+'
    id 'net.darkhax.curseforgegradle' version '1.0.+' apply false
    id 'com.modrinth.minotaur' version '2.7.+' apply false
    id 'com.diffplug.spotless' version '6.13.0' apply false
    id 'com.palantir.git-version' version '3.0.0' apply false
}

if (verifySettingsGradle()) {
    throw new GradleException("Settings has been updated, please re-run task.")
}

def out = services.get(StyledTextOutputFactory).create('an-output')


// Project properties

// Required properties: we don't know how to handle these being missing gracefully
checkPropertyExists("modName")
checkPropertyExists("modId")
checkPropertyExists("modGroup")
checkPropertyExists("modVersion")
checkPropertyExists("minecraftVersion") // hardcoding this makes it harder to immediately tell what version a mod is in (even though this only really supports 1.12.2)
checkPropertyExists("apiPackage")
checkPropertyExists("accessTransformersFile")
checkPropertyExists("usesMixins")
checkPropertyExists("mixinsPackage")
checkPropertyExists("coreModClass")
checkPropertyExists("containsMixinsAndOrCoreModOnly")

// Optional properties: we can assume some default behavior if these are missing
propertyDefaultIfUnset("autoUpdateBuildScript", false)
propertyDefaultIfUnset("modArchivesBaseName", project.modId)
propertyDefaultIfUnset("developmentEnvironmentUserName", "Developer")
propertyDefaultIfUnset("generateGradleTokenClass", "")
propertyDefaultIfUnset("gradleTokenModId", "")
propertyDefaultIfUnset("gradleTokenModName", "")
propertyDefaultIfUnset("gradleTokenVersion", "")

propertyDefaultIfUnset("includeWellKnownRepositories", true)
propertyDefaultIfUnset("noPublishedSources", false)
propertyDefaultIfUnset("forceEnableMixins", false)
propertyDefaultIfUnset("modrinthProjectId", "")
propertyDefaultIfUnset("modrinthRelations", "")
propertyDefaultIfUnset("curseForgeProjectId", "")
propertyDefaultIfUnset("curseForgeRelations", "")
propertyDefaultIfUnset("enableModernJavaSyntax", false)
propertyDefaultIfUnset("enableSpotless", false)
propertyDefaultIfUnset("enableJUnit", false)
propertyDefaultIfUnset("deploymentDebug", providers.environmentVariable('DEPLOYMENT_DEBUG').getOrElse("false").toBoolean())


// Project property assertions

final String javaSourceDir = 'src/main/java/'
// If Scala or Kotlin are supported, add those paths here

final String modGroupPath = modGroup.toString().replace('.' as char, '/' as char)
final String apiPackagePath = apiPackage.toString().replace('.' as char, '/' as char)

String targetPackageJava = javaSourceDir + modGroupPath
// If Scala or Kotlin are supported, add those paths here

if (!getFile(targetPackageJava).exists()) {
    throw new GradleException("Could not resolve \"modGroup\"! Could not find " + targetPackageJava)
}

if (apiPackage) {
    targetPackageJava = javaSourceDir + modGroupPath + '/' + apiPackagePath
    if (!getFile(targetPackageJava).exists()) {
        throw new GradleException("Could not resolve \"apiPackage\"! Could not find " + targetPackageJava)
    }
}

if (accessTransformersFile) {
    for (atFile in accessTransformersFile.split(",")) {
        String targetFile = 'src/main/resources/META-INF/' + atFile.trim()
        if (!getFile(targetFile).exists()) {
            throw new GradleException("Could not resolve \"accessTransformersFile\"! Could not find " + targetFile)
        }
        tasks.deobfuscateMergedJarToSrg.accessTransformerFiles.from(targetFile)
        tasks.srgifyBinpatchedJar.accessTransformerFiles.from(targetFile)
    }
}

if (usesMixins.toBoolean()) {
    if (mixinsPackage.isEmpty()) {
        throw new GradleException("\"usesMixins\" requires \"mixinsPackage\" to be set!")
    }
    final String mixinPackagePath = mixinsPackage.toString().replaceAll('\\.', '/')
    targetPackageJava = javaSourceDir + modGroupPath + '/' + mixinPackagePath
    if (!getFile(targetPackageJava).exists()) {
        throw new GradleException("Could not resolve \"mixinsPackage\"! Could not find " + targetPackageJava)
    }
}

if (coreModClass) {
    final String coreModPath = coreModClass.toString().replaceAll('\\.', '/')
    String targetFileJava = javaSourceDir + modGroupPath + '/' + coreModPath + '.java'
    if (!getFile(targetFileJava).exists()) {
        throw new GradleException("Could not resolve \"coreModClass\"! Could not find " + targetFileJava)
    }
}


// Plugin application

// Spotless
project.extensions.add(Blowdryer, 'Blowdryer', Blowdryer) // make Blowdryer available in plugin application
if (enableSpotless.toBoolean()) {
    apply plugin: 'com.diffplug.spotless'
    apply from: Blowdryer.file('spotless.gradle')
}

// Git submodules
if (project.file('.git/HEAD').isFile() || project.file('.git').isFile()) {
    apply plugin: 'com.palantir.git-version'
}


// Configure Java

java {
    toolchain {
        if (enableModernJavaSyntax.toBoolean()) {
            languageVersion.set(JavaLanguageVersion.of(17))
        } else {
            languageVersion.set(JavaLanguageVersion.of(8))
        }
        // Azul covers the most platforms for Java 8+ toolchains, crucially including MacOS arm64
        vendor.set(JvmVendorSpec.AZUL)
    }
    if (!noPublishedSources) {
        withSourcesJar()
    }
}

tasks.withType(JavaCompile).configureEach {
    options.encoding = 'UTF-8'

    if (enableModernJavaSyntax.toBoolean()) {
        if (it.name in ['compileMcLauncherJava', 'compilePatchedMcJava']) {
            return
        }

        sourceCompatibility = 17
        options.release.set(8)

        javaCompiler.set(javaToolchains.compilerFor {
            languageVersion.set(JavaLanguageVersion.of(17))
            vendor.set(JvmVendorSpec.AZUL)
        })
    }
}


// Configure Minecraft

version = modVersion
group = modGroup
archivesBaseName = modArchivesBaseName

minecraft {
    mcVersion = minecraftVersion
    username = developmentEnvironmentUserName.toString()
    useDependencyAccessTransformers = true

    // Automatic token injection with RetroFuturaGradle
    if (gradleTokenModId) {
        injectedTags.put gradleTokenModId, modId
    }
    if (gradleTokenModName) {
        injectedTags.put gradleTokenModName, modName
    }
    if (gradleTokenVersion) {
        injectedTags.put gradleTokenVersion, modVersion
    }

    // JVM arguments
    extraRunJvmArguments.add("-ea:${modGroup}")
    if (usesMixins.toBoolean()) {
        extraRunJvmArguments.addAll([
            '-Dmixin.hotSwap=true',
            '-Dmixin.checks.interfaces=true',
            '-Dmixin.debug.export=true'
        ])
    }
    if (coreModClass) {
        extraRunJvmArguments.add("-Dfml.coreMods.load=${coreModClass}")
    }
}

if (generateGradleTokenClass) {
    tasks.injectTags.outputClassName.set(generateGradleTokenClass)
}

tasks.named('processIdeaSettings').configure {
    dependsOn('injectTags')
}


// Allow others using this buildscript to have custom gradle code run
if (getFile('addon.gradle').exists()) {
    apply from: 'addon.gradle'
}


// Repositories

// Allow unsafe repos but warn
repositories.configureEach { repo ->
    if (repo instanceof UrlArtifactRepository) {
        if (repo.getUrl() != null && repo.getUrl().getScheme() == "http" && !repo.allowInsecureProtocol) {
            logger.warn("Deprecated: Allowing insecure connections for repo '${repo.name}' - add 'allowInsecureProtocol = true'")
            repo.allowInsecureProtocol = true
        }
    }
}

// Allow adding custom repositories to the buildscript
if (getFile('repositories.gradle').exists()) {
    apply from: 'repositories.gradle'
}

repositories {
    if (includeWellKnownRepositories.toBoolean()) {
        maven {
            name 'Cleanroom Maven'
            url 'https://maven.cleanroommc.com'
        }
        maven {
            name 'BlameJared Maven'
            url 'https://maven.blamejared.com'
        }
        maven {
            name 'Curse Maven'
            url 'https://www.cursemaven.com'
            content {
                includeGroup 'curse.maven'
            }
        }
    }
    if (usesMixins.toBoolean() || forceEnableMixins.toBoolean()) {
        maven {
            name 'Sponge Maven'
            url 'https://repo.spongepowered.org/maven'
        }
        // need to add this here even if we did not above
        if (!includeWellKnownRepositories.toBoolean()) {
            maven {
                name 'Cleanroom Maven'
                url 'https://maven.cleanroommc.com'
            }
        }
    }
    mavenLocal() // Must be last for caching to work
}


// Dependencies

// Configure dependency configurations
configurations {
    embed
    implementation.extendsFrom(embed)
}

dependencies {
    if (usesMixins.toBoolean() || forceEnableMixins.toBoolean()) {
        implementation 'zone.rong:mixinbooter:7.0'
        api('org.spongepowered:mixin:0.8.3') {
            transitive = false
        }
        annotationProcessor('org.spongepowered:mixin:0.8.3') {
            transitive = false
        }

        annotationProcessor 'org.ow2.asm:asm-debug-all:5.2'
        // should use 24.1.1 but 30.0+ has a vulnerability fix
        annotationProcessor 'com.google.guava:guava:30.0-jre'
        // should use 2.8.6 but 2.8.9+ has a vulnerability fix
        annotationProcessor 'com.google.code.gson:gson:2.8.9'
    }

    if (enableJUnit.toBoolean()) {
        testImplementation 'org.junit.jupiter:junit-jupiter:5.9.1'
        testImplementation 'org.hamcrest:hamcrest:2.2'
    }

    if (enableModernJavaSyntax.toBoolean()) {
        annotationProcessor 'com.github.bsideup.jabel:jabel-javac-plugin:1.0.0'
        compileOnly('com.github.bsideup.jabel:jabel-javac-plugin:1.0.0') {
            transitive = false
        }
        // workaround for https://github.com/bsideup/jabel/issues/174
        annotationProcessor 'net.java.dev.jna:jna-platform:5.13.0'
        // Allow jdk.unsupported classes like sun.misc.Unsafe, workaround for JDK-8206937 and fixes Forge crashes in tests.
        patchedMinecraft 'me.eigenraven.java8unsupported:java-8-unsupported-shim:1.0.0'

        // allow Jabel to work in tests
        testAnnotationProcessor "com.github.bsideup.jabel:jabel-javac-plugin:1.0.0"
        testCompileOnly("com.github.bsideup.jabel:jabel-javac-plugin:1.0.0") {
            transitive = false // We only care about the 1 annotation class
        }
        testCompileOnly "me.eigenraven.java8unsupported:java-8-unsupported-shim:1.0.0"
    }
}

if (getFile('dependencies.gradle').exists()) {
    apply from: 'dependencies.gradle'
}


// Test configuration

// Ensure tests have access to minecraft classes
sourceSets {
    test {
        java {
            compileClasspath += patchedMc.output + mcLauncher.output
            runtimeClasspath += patchedMc.output + mcLauncher.output
        }
    }
}

test {
    // ensure tests are run with java8
    javaLauncher = javaToolchains.launcherFor {
        languageVersion = JavaLanguageVersion.of(8)
    }.get()

    testLogging {
        events TestLogEvent.STARTED, TestLogEvent.PASSED, TestLogEvent.FAILED
        exceptionFormat TestExceptionFormat.FULL
        showExceptions true
        showStackTraces true
        showCauses true
        showStandardStreams true
    }

    if (enableJUnit.toBoolean()) {
        useJUnitPlatform()
    }
}


// Resource processing and jar building

processResources {
    // this will ensure that this task is redone when the versions change.
    inputs.property 'version', modVersion
    inputs.property 'mcversion', minecraftVersion
    exclude('spotless.gradle')

    // replace stuff in mcmod.info, nothing else
    filesMatching(['mcmod.info', 'pack.mcmeta']) { fcd ->
        // replace version and mcversion
        fcd.expand(
                'version': modVersion,
                'mcversion': minecraftVersion
        )
    }
}

// Automatically generate a mixin json file if it does not already exist
tasks.register('generateAssets') {
    group = 'GT Buildscript'
    description = 'Generates a mixin config file at /src/main/resources/mixins.modid.json if needed'
    onlyIf {
        usesMixins.toBoolean()
    }
    doLast {
        def mixinConfigFile = getFile("src/main/resources/mixins.${modId}.json")
        if (!mixinConfigFile.exists()) {
            def mixinConfigRefmap = "mixins.${modId}.refmap.json"

            mixinConfigFile.text = """{
  "package": "${modGroup}.${mixinsPackage}",
  "refmap": "${mixinConfigRefmap}",
  "target": "@env(DEFAULT)",
  "minVersion": "0.8",
  "compatibilityLevel": "JAVA_8",
  "mixins": [],
  "client": [],
  "server": []
}
"""
        }
    }
}

if (usesMixins.toBoolean()) {
    tasks.named('processResources').configure {
        dependsOn('generateAssets')
    }
}

jar {
    manifest {
        def attribute_map = [:]
        if (coreModClass) {
            attribute_map['FMLCorePlugin'] = "${modGroup}.${coreModClass}"
        }
        if (!containsMixinsAndOrCoreModOnly.toBoolean() && (usesMixins.toBoolean() || coreModClass)) {
            attribute_map['FMLCorePluginContainsFMLMod'] = true
        }
        if (accessTransformersFile) {
            attribute_map['FMLAT'] = accessTransformersFile.toString()
        }

        if (usesMixins.toBoolean()) {
            attribute_map['ForceLoadAsMod'] = !containsMixinsAndOrCoreModOnly.toBoolean()
        }
        attributes(attribute_map)
    }

    // Add all embedded dependencies into the jar
    from provider {
        configurations.embed.collect {
            it.isDirectory() ? it : zipTree(it)
        }
    }
}

// Create API library jar
tasks.register('apiJar', Jar) {
    archiveClassifier.set 'api'
    from(sourceSets.main.java) {
        include "${modGroupPath}/${apiPackagePath}/**"
    }

    from(sourceSets.main.output) {
        include "${modGroupPath}/${apiPackagePath}/**"
    }
}


// IDE Configuration

eclipse {
    classpath {
        downloadSources = true
        downloadJavadoc = true
    }
}

idea {
    module {
        inheritOutputDirs true
        downloadJavadoc true
        downloadSources true
    }
    project {
        settings {
            runConfigurations {
                '1. Run Client'(Gradle) {
                    taskNames = ['runClient']
                }
                '2. Run Server'(Gradle) {
                    taskNames = ['runServer']
                }
                '3. Run Obfuscated Client'(Gradle) {
                    taskNames = ['runObfClient']
                }
                '4. Run Obfuscated Server'(Gradle) {
                    taskNames = ['runObfServer']
                }
                if (enableSpotless.toBoolean()) {
                    "5. Apply Spotless"(Gradle) {
                        taskNames = ["spotlessApply"]
                    }
                }
            }
            compiler.javac {
                afterEvaluate {
                    javacAdditionalOptions = '-encoding utf8'
                    moduleJavacAdditionalOptions = [
                            (project.name + '.main'): tasks.compileJava.options.compilerArgs.collect {
                                '"' + it + '"'
                            }.join(' ')
                    ]
                }
            }
        }
    }
}


// Deployment

final boolean isCIEnv = providers.environmentVariable('CI').getOrElse('false').toBoolean()
def final changelogEnv = providers.environmentVariable('CHANGELOG_LOCATION')
File changelogFile = new File(changelogEnv.isPresent() ? changelogEnv.get() : 'CHANGELOG.md')

if (isCIEnv || deploymentDebug.asBoolean()) {
    artifacts {
        if (!noPublishedSources.toBoolean()) {
            archives sourcesJar
        }
        if (apiPackage) {
            archives apiJar
        }
    }
}

// Curseforge
def final cfApiKey = providers.environmentVariable('CURSEFORGE_API_KEY')
if (cfApiKey.isPresent() || deploymentDebug.asBoolean()) {
    apply plugin: 'net.darkhax.curseforgegradle'
    //noinspection UnnecessaryQualifiedReference
    tasks.register('curseforge', net.darkhax.curseforgegradle.TaskPublishCurseForge) {
        apiToken = cfApiKey.get()
        def mainFile = upload(curseForgeProjectId, reobfJar)
        def changelogRaw = changelogFile.exists() ? changelogFile.getText('UTF-8') : ""

        mainFile.releaseType = providers.environmentVariable('RELEASE_TYPE').get() // todo
        mainFile.changelog = changelogRaw
        mainFile.changelogType = 'markdown'
        mainFile.addModLoader 'Forge'
        mainFile.addJavaVersion "Java 8"
        mainFile.addGameVersion minecraftVersion

        if (curseForgeRelations.size() != 0) {
            String[] deps = curseForgeRelations.split(';')
            deps.each { dep ->
                if (dep.size() == 0) {
                    return
                }
                String parts = dep.split(':')
                switch (parts[0]) {
                    case 'requiredDependency':
                        mainFile.addRequirement parts[1]
                        break
                    case 'embeddedLibrary':
                        mainFile.addEmbedded parts[1]
                        break
                    case 'optionalDependency':
                        mainFile.addOptional parts[1]
                        break
                    case 'tool':
                        mainFile.addTool parts[1]
                        break
                    case 'incompatible':
                        mainFile.addIncompatibility parts[1]
                        break
                    default:
                        throw new Exception('Invalid CurseForge relation type: ' + type)
                }
            }
        }

        for (artifact in getSecondaryArtifacts()) {
            def additionalFile = mainFile.withAdditionalFile(artifact)
            additionalFile.changelog = changelogRaw
        }
        disableVersionDetection()
    }
    tasks.curseforge.dependsOn(build)
}

// Modrinth
def final modrinthApiKey = providers.environmentVariable('MODRINTH_API_KEY')
if (modrinthApiKey.isPresent() || deploymentDebug.asBoolean()) {
    apply plugin: 'com.modrinth.minotaur'

    modrinth {
        token = modrinthApiKey.get()
        projectId = modrinthProjectId
        changelog = changelogFile.exists() ? changelogFile.getText('UTF-8') : ""
        versionType = providers.environmentVariable("RELEASE_TYPE").get() // todo
        versionNumber = modVersion
        gameVersions = [minecraftVersion]
        loaders = ["forge"]
        debugMode = deploymentDebug.asBoolean()
        uploadFile = file("build/libs/${archivesBaseName}-${version}.jar")
        additionalFiles = getSecondaryArtifacts()
    }
    if (modrinthRelations.size() != 0) {
        String[] deps = modrinthRelations.split(';')
        deps.each { dep ->
            if (dep.size() == 0) {
                return
            }
            String[] parts = dep.split(':')
            String qual = parts[0].split('-')
            addModrinthDep(qual[0], qual[1], parts[1])
        }
    }
    tasks.modrinth.dependsOn(build)
}

def addModrinthDep(String scope, String type, String name) {
    com.modrinth.minotaur.dependencies.Dependency dep;
    if (!(scope in ['required', 'optional', 'incompatible', 'embedded'])) {
        throw new Exception('Invalid modrinth dependency scope: ' + scope)
    }
    switch (type) {
        case 'project':
            dep = new ModDependency(name, scope)
            break
        case 'version':
            dep = new VersionDependency(name, scope)
            break
        default:
            throw new Exception('Invalid modrinth dependency type: ' + type)
    }
    project.modrinth.dependencies.add(dep)
}


// Buildscript updating

def buildscriptGradleVersion = '8.1.1'

tasks.named('wrapper', Wrapper).configure {
    gradleVersion = buildscriptGradleVersion
}

tasks.register('updateBuildScript') {
    group = 'GT Buildscript'
    description = 'Updates the build script to the latest version'

    if (gradle.gradleVersion != buildscriptGradleVersion && !Boolean.getBoolean('DISABLE_BUILDSCRIPT_GRADLE_UPDATE')) {
        dependsOn('wrapper')
    }

    doLast {
        if (performBuildScriptUpdate()) return
        print('Build script already up to date!')
    }
}

if (!project.getGradle().startParameter.isOffline() && !Boolean.getBoolean('DISABLE_BUILDSCRIPT_UPDATE_CHECK') && isNewBuildScriptVersionAvailable()) {
    if (autoUpdateBuildScript.toBoolean()) {
        performBuildScriptUpdate()
    } else {
        out.style(Style.SuccessHeader).println("Build script update available! Run 'gradle updateBuildScript'")
        if (gradle.gradleVersion != buildscriptGradleVersion) {
            out.style(Style.SuccessHeader).println("updateBuildScript can update gradle from ${gradle.gradleVersion} to ${buildscriptGradleVersion}\n")
        }
    }
}

static URL availableBuildScriptUrl() {
    new URL("https://raw.githubusercontent.com/GregTechCEu/Buildscripts/master/build.gradle")
}

static URL exampleSettingsGradleUrl() {
    new URL("https://raw.githubusercontent.com/GregTechCEu/Buildscripts/master/settings.gradle")
}

boolean verifySettingsGradle() {
    def settingsFile = getFile("settings.gradle")
    if (!settingsFile.exists()) {
        println("Downloading default settings.gradle")
        exampleSettingsGradleUrl().withInputStream { i -> settingsFile.withOutputStream { it << i } }
        return true
    }
    return false
}

boolean performBuildScriptUpdate() {
    if (isNewBuildScriptVersionAvailable()) {
        def buildscriptFile = getFile("build.gradle")
        availableBuildScriptUrl().withInputStream { i -> buildscriptFile.withOutputStream { it << i } }
        def out = services.get(StyledTextOutputFactory).create('buildscript-update-output')
        out.style(Style.Success).print("Build script updated. Please REIMPORT the project or RESTART your IDE!")
        if (verifySettingsGradle()) {
            throw new GradleException("Settings has been updated, please re-run task.")
        }
        return true
    }
    return false
}

boolean isNewBuildScriptVersionAvailable() {
    Map parameters = ["connectTimeout": 2000, "readTimeout": 2000]

    String currentBuildScript = getFile("build.gradle").getText()
    String currentBuildScriptHash = getVersionHash(currentBuildScript)
    String availableBuildScript = availableBuildScriptUrl().newInputStream(parameters).getText()
    String availableBuildScriptHash = getVersionHash(availableBuildScript)

    boolean isUpToDate = currentBuildScriptHash.empty || availableBuildScriptHash.empty || currentBuildScriptHash == availableBuildScriptHash
    return !isUpToDate
}

static String getVersionHash(String buildScriptContent) {
    String versionLine = buildScriptContent.find("^//version: [a-z0-9]*")
    if (versionLine != null) {
        return versionLine.split(": ").last()
    }
    return ""
}


// Helpers

def getFile(String relativePath) {
    return new File(projectDir, relativePath)
}

def checkPropertyExists(String propertyName) {
    if (!project.hasProperty(propertyName)) {
        throw new GradleException("This project requires a property \"" + propertyName + "\"! Please add it your \"gradle.properties\". You can find all properties and their description here: https://github.com/GregTechCEu/Buildscripts/blob/main/gradle.properties")
    }
}

def propertyDefaultIfUnset(String propertyName, defaultValue) {
    if (!project.hasProperty(propertyName) || project.property(propertyName) == "") {
        project.ext.setProperty(propertyName, defaultValue)
    }
}

def getSecondaryArtifacts() {
    def secondaryArtifacts = [publishableDevJar]
    if (!noPublishedSources) secondaryArtifacts += [sourcesJar]
    if (apiPackage) secondaryArtifacts += [apiJar]
    return secondaryArtifacts
}
