//file:noinspection DependencyNotationArgument
// TODO remove when fixed in RFG ^

import net.darkhax.curseforgegradle.TaskPublishCurseForge
import org.gradle.api.tasks.testing.logging.TestExceptionFormat
import org.gradle.api.tasks.testing.logging.TestLogEvent
import org.jetbrains.gradle.ext.Gradle

plugins {
    id 'java'
    id 'java-library'
    id 'maven-publish'
    id 'eclipse'
    id 'org.jetbrains.gradle.plugin.idea-ext' version "${idea_ext_version}"
    id 'com.gtnewhorizons.retrofuturagradle' version "${rfg_version}"
    id 'net.darkhax.curseforgegradle' version "${curseforge_gradle_version}" apply false
    id 'com.modrinth.minotaur' version "${minotaur_version}" apply false
}

version = project.mod_version
group = project.maven_group
archivesBaseName = project.archives_base_name

// Set the toolchain version to decouple the Java we run Gradle with from the Java used to compile and run the mod
java {
    toolchain {
        // Azul covers the most platforms for Java 8 toolchains, crucially including MacOS arm64
        vendor.set(JvmVendorSpec.AZUL)
        languageVersion.set(JavaLanguageVersion.of(project.java_version))
    }

    // Generate sources when building and publishing
    withSourcesJar()
    // javadoc jar throws errors on incomplete docs
    // docs are also contained in the sources jar, so omit the javadoc-only jar
}

tasks.withType(JavaCompile).configureEach {
    options.encoding 'UTF-8'
}

configurations {
    embed
    implementation.extendsFrom(embed)
}

minecraft {
    mcVersion = project.mc_version
    def args = [
            "-ea:${project.group}",
            "-Dfml.coreMods.load=${coremod_plugin_class_name}"
    ]
    extraRunJvmArguments.addAll(args)

    injectedTags.put('VERSION', project.version)
}

// Generate a my.project.Tags class with the version number as a field
tasks.injectTags.configure {
    outputClassName.set("${project.group}.Tags")
}

repositories {
    maven {
        // MixinBooter
        name 'Cleanroom Maven'
        url 'https://maven.cleanroommc.com'
    }
    maven {
        // JEI
        name 'Progwml6 Maven'
        url 'https://dvs1.progwml6.com/files/maven/'
    }
    maven {
        // CraftTweaker and JEI Backup
        name 'BlameJared Maven'
        url 'https://maven.blamejared.com'
    }
    maven {
        // TOP, CTM, GRS, AE2
        name 'Curse Maven'
        url 'https://www.cursemaven.com'
        content {
            includeGroup 'curse.maven'
        }
    }
    maven {
        // Mixin
        name 'Sponge Maven'
        url 'https://repo.spongepowered.org/maven'
    }
    mavenLocal() // Must be last for caching to work
}

dependencies {
    // Hard Dependencies
    // the CCL deobf jar uses very old MCP mappings, making it error at runtime in runClient/runServer
    // therefore we manually deobf the regular jar
    implementation rfg.deobf("curse.maven:codechicken-lib-1-8-${ccl_pid}:${ccl_fid}")

    // Soft Dependencies
    implementation "mezz.jei:jei_1.12.2:${project.jei_version}"
    implementation "CraftTweaker2:CraftTweaker2-MC1120-Main:1.12-${project.crt_version}"
    implementation rfg.deobf("curse.maven:top-${top_pid}:${top_fid}")
    implementation rfg.deobf("curse.maven:ctm-${ctm_pid}:${ctm_fid}")

    // use a local jar for GroovyScript to avoid a bug from Mixin and ForgeGradle,
    // causing crashes at run-time when deobfuscated
    implementation files("libs/groovyscript-0.4.0.jar")
    //implementation fg.deobf("curse.maven:groovyscript-${grs_pid}:${grs_fid}")
    implementation rfg.deobf("curse.maven:ae2-extended-life-${ae2_pid}:${ae2_fid}")

    // Tests
    testImplementation "org.junit.jupiter:junit-jupiter:${junit_version}"
    testImplementation "org.hamcrest:hamcrest:${hamcrest_version}"

    // Compile-Time Dependencies

    // GroovyScript dependency
    implementation "zone.rong:mixinbooter:${mixinbooter_version}"

    // Mixin dependencies
    api ("org.spongepowered:mixin:${mixin_version}") {
        transitive = false
    }
    annotationProcessor ("org.spongepowered:mixin:${mixin_version}") {
        transitive = false
    }

    annotationProcessor "org.ow2.asm:asm-debug-all:${asm_debug_version}"
    annotationProcessor "com.google.guava:guava:${guava_version}-jre"
    annotationProcessor "com.google.code.gson:gson:${gson_version}"
}

//noinspection ConfigurationAvoidance
for (File at : sourceSets.getByName('main').resources.files) {
    if (at.name.toLowerCase().endsWith('_at.cfg')) {
        tasks.deobfuscateMergedJarToSrg.accessTransformerFiles.from at
        tasks.srgifyBinpatchedJar.accessTransformerFiles.from at
    }
}

processResources {
    // this will ensure that this task is redone when the versions change.
    inputs.property 'version', project.version
    inputs.property 'mcversion', project.minecraft.version
    // replace stuff in mcmod.info, nothing else
    filesMatching(['mcmod.info', 'pack.mcmeta']) { fcd ->
        include 'mcmod.info'
        // replace version and mcversion
        fcd.expand (
            'version': project.version,
            'mcversion': project.minecraft.version
        )
    }

    rename '(.+_at.cfg)', 'META-INF/$1' // Access Transformers
}

jar {
    manifest {
        def attribute_map = [:]
        attribute_map['FMLCorePlugin'] = project.coremod_plugin_class_name
        attribute_map['FMLCorePluginContainsFMLMod'] = true
        attribute_map['ForceLoadAsMod'] = project.gradle.startParameter.taskNames[0] == 'build'
        attribute_map['FMLAT'] = project.archives_base_name + '_at.cfg'
        attributes(attribute_map)
    }

    // Add all embedded dependencies into the jar
    from provider {
        configurations.embed.collect {
            it.isDirectory() ? it : zipTree(it)
        }
    }
}

test {
    testLogging {
        events TestLogEvent.STARTED, TestLogEvent.PASSED, TestLogEvent.FAILED
        exceptionFormat TestExceptionFormat.FULL
        showExceptions true
        showStackTraces true
        showCauses true
        showStandardStreams true
    }

    useJUnitPlatform()
}

idea {
    module {
        inheritOutputDirs true
        downloadJavadoc true
        downloadSources true
    }
    project {
        settings {
            runConfigurations {
                '1. Run Client'(Gradle) {
                    taskNames = ['runClient']
                }
                '2. Run Server'(Gradle) {
                    taskNames = ['runServer']
                }
                '3. Run Obfuscated Client'(Gradle) {
                    taskNames = ['runObfClient']
                }
                '4. Run Obfuscated Server'(Gradle) {
                    taskNames = ['runObfServer']
                }
            }
            compiler.javac {
                afterEvaluate {
                    javacAdditionalOptions = '-encoding utf8'
                    moduleJavacAdditionalOptions = [
                        (project.name + '.main'): tasks.compileJava.options.compilerArgs.collect {
                            '"' + it + '"'
                        }.join(' ')
                    ]
                }
            }
        }
    }
}

// Create API library jar
tasks.register('apiJar', Jar) {
    archiveClassifier.set 'api'
    from(sourceSets.main.java) {
        include 'gregtech/api/**'
    }

    from(sourceSets.main.output) {
        include 'gregtech/api/**'
    }
}

sourceSets {
    test {
        java {
            compileClasspath += sourceSets.patchedMc.output + sourceSets.mcLauncher.output
            runtimeClasspath += sourceSets.patchedMc.output + sourceSets.mcLauncher.output
        }
    }
}

tasks.named('processIdeaSettings').configure {
    dependsOn('injectTags')
}

// Deployment

final boolean is_ci_env = providers.environmentVariable('CI').getOrElse('false').toBoolean()
final boolean deployment_debug = providers.environmentVariable('DEPLOYMENT_DEBUG').getOrElse('false').toBoolean()

if (is_ci_env || deployment_debug) {
    artifacts {
        archives jar
        archives apiJar
        archives sourcesJar
    }
}

def final cf_api_key = providers.environmentVariable('CURSEFORGE_API_KEY')
if (cf_api_key.isPresent() || deployment_debug) {
    apply plugin: 'net.darkhax.curseforgegradle'
    tasks.register('curseforge', TaskPublishCurseForge) {
        apiToken = cf_api_key.get()
        def final projectId = providers.environmentVariable('CURSEFORGE_PROJECT_ID').get()

        def mainFile = upload(projectId, build)
        mainFile.releaseType = providers.environmentVariable('RELEASE_TYPE').get()
        mainFile.changelog = providers.environmentVariable('CHANGELOG_LOCATION').get()
        mainFile.changelogType = 'markdown'
        mainFile.addRequirement 'codechicken-lib-1-8'
        mainFile.addIncompatibility 'gregtechce'
        mainFile.addModLoader 'Forge'
        mainFile.addJavaVersion "${java_version}"
        mainFile.addGameVersion "${minecraft_version}"

        def sourcesFile = mainFile.withAdditionalFile(sourcesJar)
        sourcesFile.changelog = providers.environmentVariable('CHANGELOG_LOCATION').get()

        def devFile = mainFile.withAdditionalFile(jar)
        devFile.changelog = providers.environmentVariable('CHANGELOG_LOCATION').get()

        disableVersionDetection()
    }

    tasks.curseforge.dependsOn(build)
}

def final modrinth_api_key = providers.environmentVariable('MODRINTH_API_KEY')
if (modrinth_api_key.isPresent() || deployment_debug) {
    apply plugin: 'com.modrinth.minotaur'

    modrinth {
        token = modrinth_api_key.get()
        projectId = providers.environmentVariable("MODRINTH_PROJECT_ID").get()
        changelog = providers.environmentVariable("CHANGELOG_LOCATION").get()
        versionType = providers.environmentVariable("RELEASE_TYPE").get()

        versionNumber = getVersionFromJava(false)
        gameVersions = ["${minecraft_version}"]

        def main_artifact = "${archivesBaseName}-${version}.jar"
        uploadFile = file("build/libs/${main_artifact}")
        file('build/libs/').eachFile { file ->
            if (file.name.endsWith('.jar') && file.name != main_artifact) {
                additionalFiles.add file
            }
        }

        debugMode = "${project.deployment_debug}".toBoolean() || deployment_debug
    }
    tasks.modrinth.dependsOn(build)
}

