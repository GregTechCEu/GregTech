//version: 1685391779
//file:noinspection DependencyNotationArgument
// TODO remove when fixed in RFG ^

import org.gradle.api.tasks.testing.logging.TestExceptionFormat
import org.gradle.api.tasks.testing.logging.TestLogEvent
import org.gradle.internal.logging.text.StyledTextOutput.Style
import org.gradle.internal.logging.text.StyledTextOutputFactory
import org.jetbrains.gradle.ext.Gradle

plugins {
    id 'java'
    id 'java-library'
    id 'eclipse'
    id 'org.jetbrains.gradle.plugin.idea-ext' version "$idea_ext_version"
    id 'com.gtnewhorizons.retrofuturagradle' version "$rfg_version"
    id 'net.darkhax.curseforgegradle' version "$curseforge_gradle_version" apply false
    id 'com.modrinth.minotaur' version "$minotaur_version" apply false
}

if (verifySettingsGradle()) {
    throw new GradleException("Settings has been updated, please re-run task.")
}

def out = services.get(StyledTextOutputFactory).create('an-output')

version = project.mod_version
group = project.maven_group
archivesBaseName = project.archives_base_name

// Declare java compilation and java compatibility versions as groovy variables to prevent configuration errors when
// extracting values from the gradle.properties file
def javaVersion = project.java_version
def javaCompatVersion = project.java_compat_version

// Set the toolchain version to decouple the Java we run Gradle with from the Java used to compile and run the mod
java {
    toolchain {
        // Azul covers the most platforms for Java 8+ toolchains, crucially including MacOS arm64
        vendor.set(JvmVendorSpec.AZUL)
        languageVersion.set(JavaLanguageVersion.of(javaVersion))
    }

    // Generate sources when building and publishing
    withSourcesJar()
    // javadoc jar throws errors on incomplete docs
    // docs are also contained in the sources jar, so omit the javadoc-only jar
}

tasks.withType(JavaCompile).configureEach {
    // prevent compiling MC with newer java versions
    if (it.name in ['compileMcLauncherJava', 'compilePatchedMcJava']) {
        return
    }

    options.encoding 'UTF-8'

    // Enable Java17 for all other compilation tasks
    sourceCompatibility = javaVersion
    targetCompatibility = javaCompatVersion
    options.release.set(Integer.parseInt(javaCompatVersion))

    javaCompiler.set(javaToolchains.compilerFor {
        languageVersion.set(JavaLanguageVersion.of(javaVersion))
        vendor.set(JvmVendorSpec.AZUL)
    })
}

configurations {
    embed
    implementation.extendsFrom(embed)
}

minecraft {
    mcVersion = project.mc_version
    def args = [
            "-ea:${project.group}",
            "-Dfml.coreMods.load=${coremod_plugin_class_name}"
    ]
    extraRunJvmArguments.addAll(args)

    useDependencyAccessTransformers = true

    injectedTags.put('VERSION', project.version)
    injectedTags.put("DEP_VERSION_STRING", "required-after:gregtech@[" + project.version + ",);")
}

// Generate the InternalTags class with the version number as a field
tasks.injectTags.configure {
    outputClassName.set("${project.group}.GTInternalTags")
}

repositories {
    maven {
        // MixinBooter
        name 'Cleanroom Maven'
        url 'https://maven.cleanroommc.com'
    }
    maven {
        // CraftTweaker and JEI
        name 'BlameJared Maven'
        url 'https://maven.blamejared.com'
    }
    maven {
        // TOP, CTM, GRS, AE2
        name 'Curse Maven'
        url 'https://www.cursemaven.com'
        content {
            includeGroup 'curse.maven'
        }
    }
    maven {
        // Mixin
        name 'Sponge Maven'
        url 'https://repo.spongepowered.org/maven'
    }
    mavenLocal() // Must be last for caching to work
}

apply from: 'dependencies.gradle'

//noinspection ConfigurationAvoidance
for (File at : sourceSets.getByName('main').resources.files) {
    if (at.name.toLowerCase().endsWith('_at.cfg')) {
        tasks.deobfuscateMergedJarToSrg.accessTransformerFiles.from at
        tasks.srgifyBinpatchedJar.accessTransformerFiles.from at
    }
}

processResources {
    // this will ensure that this task is redone when the versions change.
    inputs.property 'version', project.version
    inputs.property 'mcversion', project.minecraft.version
    // replace stuff in mcmod.info, nothing else
    filesMatching(['mcmod.info', 'pack.mcmeta']) { fcd ->
        // replace version and mcversion
        fcd.expand(
                'version': project.version,
                'mcversion': project.minecraft.version
        )
    }

    rename '(.+_at.cfg)', 'META-INF/$1' // Access Transformers
}

jar {
    manifest {
        def attribute_map = [:]
        attribute_map['FMLCorePlugin'] = coremod_plugin_class_name
        attribute_map['FMLCorePluginContainsFMLMod'] = true
        attribute_map['ForceLoadAsMod'] = project.gradle.startParameter.taskNames[0] == 'build'
        attribute_map['FMLAT'] = archives_base_name + '_at.cfg'
        attributes(attribute_map)
    }

    // Add all embedded dependencies into the jar
    from provider {
        configurations.embed.collect {
            it.isDirectory() ? it : zipTree(it)
        }
    }
}

test {
    // ensure tests are run with java8
    javaLauncher = javaToolchains.launcherFor {
        languageVersion = JavaLanguageVersion.of(javaCompatVersion)
    }.get()

    testLogging {
        events TestLogEvent.STARTED, TestLogEvent.PASSED, TestLogEvent.FAILED
        exceptionFormat TestExceptionFormat.FULL
        showExceptions true
        showStackTraces true
        showCauses true
        showStandardStreams true
    }

    useJUnitPlatform()
}

idea {
    module {
        inheritOutputDirs true
        downloadJavadoc true
        downloadSources true
    }
    project {
        settings {
            runConfigurations {
                '1. Run Client'(Gradle) {
                    taskNames = ['runClient']
                }
                '2. Run Server'(Gradle) {
                    taskNames = ['runServer']
                }
                '3. Run Obfuscated Client'(Gradle) {
                    taskNames = ['runObfClient']
                }
                '4. Run Obfuscated Server'(Gradle) {
                    taskNames = ['runObfServer']
                }
            }
            compiler.javac {
                afterEvaluate {
                    javacAdditionalOptions = '-encoding utf8'
                    moduleJavacAdditionalOptions = [
                            (project.name + '.main'): tasks.compileJava.options.compilerArgs.collect {
                                '"' + it + '"'
                            }.join(' ')
                    ]
                }
            }
        }
    }
}

// Create API library jar
tasks.register('apiJar', Jar) {
    archiveClassifier.set 'api'
    from(sourceSets.main.java) {
        include 'gregtech/api/**'
    }

    from(sourceSets.main.output) {
        include 'gregtech/api/**'
    }
}

sourceSets {
    test {
        java {
            compileClasspath += patchedMc.output + mcLauncher.output
            runtimeClasspath += patchedMc.output + mcLauncher.output
        }
    }
}

tasks.named('processIdeaSettings').configure {
    dependsOn('injectTags')
}

// Deployment

final boolean is_ci_env = providers.environmentVariable('CI').getOrElse('false').toBoolean()
final boolean deployment_debug = providers.environmentVariable('DEPLOYMENT_DEBUG').getOrElse("$deployment_debug").toBoolean()

if (is_ci_env || deployment_debug) {
    artifacts {
        archives jar
        archives apiJar
        archives sourcesJar
    }
}

def final cf_api_key = providers.environmentVariable('CURSEFORGE_API_KEY')
if (cf_api_key.isPresent() || deployment_debug) {
    apply plugin: 'net.darkhax.curseforgegradle'
    //noinspection UnnecessaryQualifiedReference
    tasks.register('curseforge', net.darkhax.curseforgegradle.TaskPublishCurseForge) {
        apiToken = cf_api_key.get()
        def final projectId = providers.environmentVariable('CURSEFORGE_PROJECT_ID').get()

        def mainFile = upload(projectId, reobfJar)
        mainFile.releaseType = providers.environmentVariable('RELEASE_TYPE').get()
        mainFile.changelog = providers.environmentVariable('CHANGELOG_LOCATION').get()
        mainFile.changelogType = 'markdown'
        mainFile.addRequirement 'codechicken-lib-1-8'
        mainFile.addIncompatibility 'gregtechce'
        mainFile.addModLoader 'Forge'
        mainFile.addJavaVersion "Java ${java_version}"
        mainFile.addGameVersion "$mc_version"

        def sourcesFile = mainFile.withAdditionalFile(sourcesJar)
        sourcesFile.changelog = providers.environmentVariable('CHANGELOG_LOCATION').get()

        def devFile = mainFile.withAdditionalFile(jar)
        devFile.changelog = providers.environmentVariable('CHANGELOG_LOCATION').get()

        disableVersionDetection()
    }

    tasks.curseforge.dependsOn(build)
}

def final modrinth_api_key = providers.environmentVariable('MODRINTH_API_KEY')
if (modrinth_api_key.isPresent() || deployment_debug) {
    apply plugin: 'com.modrinth.minotaur'

    modrinth {
        token = modrinth_api_key.get()
        projectId = providers.environmentVariable("MODRINTH_PROJECT_ID").get()
        changelog = providers.environmentVariable("CHANGELOG_LOCATION").get()
        versionType = providers.environmentVariable("RELEASE_TYPE").get()

        versionNumber = "$version".split('-')[0] // strip out the EXTRA field, if present
        gameVersions = ["$mc_version"]
        loaders = ["forge"]

        def main_artifact = "${archivesBaseName}-${version}.jar"
        uploadFile = file("build/libs/${main_artifact}")
        file('build/libs/').eachFile { file ->
            if (file.name.endsWith('.jar') && file.name != main_artifact) {
                additionalFiles.add file
            }
        }

        debugMode = deployment_debug
    }
    tasks.modrinth.dependsOn(build)
}

// Buildscript updating

def buildscriptGradleVersion = '8.1.1'

tasks.named('wrapper', Wrapper).configure {
    gradleVersion = buildscriptGradleVersion
}

tasks.register('updateBuildScript') {
    group = 'Buildscript updates'
    description = 'Updates the build script to the latest version'

    if (gradle.gradleVersion != buildscriptGradleVersion && !Boolean.getBoolean('DISABLE_BUILDSCRIPT_GRADLE_UPDATE')) {
        dependsOn('wrapper')
    }

    doLast {
        if (performBuildScriptUpdate()) return
        print('Build script already up to date!')
    }
}

if (!project.getGradle().startParameter.isOffline() && !Boolean.getBoolean('DISABLE_BUILDSCRIPT_UPDATE_CHECK') && isNewBuildScriptVersionAvailable()) {
    //if (autoUpdateBuildScript.toBoolean()) {
    //    performBuildScriptUpdate()
    //} else {
        out.style(Style.SuccessHeader).println("Build script update available! Run 'gradle updateBuildScript'")
        if (gradle.gradleVersion != buildscriptGradleVersion) {
            out.style(Style.SuccessHeader).println("updateBuildScript can update gradle from ${gradle.gradleVersion} to ${buildscriptGradleVersion}\n")
        }
    //}
}

static URL availableBuildScriptUrl() {
    new URL("https://raw.githubusercontent.com/GregTechCEu/Buildscripts/master/build.gradle")
}

static URL exampleSettingsGradleUrl() {
    new URL("https://raw.githubusercontent.com/GregTechCEu/Buildscripts/master/settings.gradle.example")
}

boolean verifySettingsGradle() {
    def settingsFile = getFile("settings.gradle")
    if (!settingsFile.exists()) {
        println("Downloading default settings.gradle")
        exampleSettingsGradleUrl().withInputStream { i -> settingsFile.withOutputStream { it << i } }
        return true
    }
    return false
}

boolean performBuildScriptUpdate() {
    if (isNewBuildScriptVersionAvailable()) {
        def buildscriptFile = getFile("build.gradle")
        availableBuildScriptUrl().withInputStream { i -> buildscriptFile.withOutputStream { it << i } }
        def out = services.get(StyledTextOutputFactory).create('buildscript-update-output')
        out.style(Style.Success).print("Build script updated. Please REIMPORT the project or RESTART your IDE!")
        boolean settingsupdated = verifySettingsGradle()
        settingsupdated = verifyGitAttributes() || settingsupdated
        if (settingsupdated)
            throw new GradleException("Settings has been updated, please re-run task.")
        return true
    }
    return false
}

boolean isNewBuildScriptVersionAvailable() {
    Map parameters = ["connectTimeout": 2000, "readTimeout": 2000]

    String currentBuildScript = getFile("build.gradle").getText()
    String currentBuildScriptHash = getVersionHash(currentBuildScript)
    String availableBuildScript = availableBuildScriptUrl().newInputStream(parameters).getText()
    String availableBuildScriptHash = getVersionHash(availableBuildScript)

    boolean isUpToDate = currentBuildScriptHash.empty || availableBuildScriptHash.empty || currentBuildScriptHash == availableBuildScriptHash
    return !isUpToDate
}

static String getVersionHash(String buildScriptContent) {
    String versionLine = buildScriptContent.find("^//version: [a-z0-9]*")
    if (versionLine != null) {
        return versionLine.split(": ").last()
    }
    return ""
}

def getFile(String relativePath) {
    return new File(projectDir, relativePath)
}
