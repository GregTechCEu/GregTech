package gregtech.api.pattern;

import gregtech.api.GregTechAPI;
import gregtech.api.metatileentity.MetaTileEntity;
import gregtech.api.metatileentity.interfaces.IGregTechTileEntity;
import gregtech.api.metatileentity.multiblock.MultiblockControllerBase;
import gregtech.api.util.BlockInfo;

import net.minecraft.block.state.IBlockState;
import net.minecraft.client.resources.I18n;
import net.minecraft.init.Blocks;
import net.minecraft.item.Item;
import net.minecraft.item.ItemStack;
import net.minecraftforge.fml.common.FMLCommonHandler;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import it.unimi.dsi.fastutil.objects.Object2IntMap;
import org.jetbrains.annotations.Nullable;

import java.util.*;
import java.util.function.Function;
import java.util.function.Supplier;
import java.util.stream.Collectors;

public class TraceabilityPredicate {

    // Allow any block.
    public static final TraceabilityPredicate ANY = new TraceabilityPredicate(worldState -> null);
    // Allow the air block.
    public static final TraceabilityPredicate AIR = new TraceabilityPredicate(
            worldState -> worldState.getBlockState().getBlock().isAir(worldState.getBlockState(),
                    worldState.getWorld(), worldState.getPos()) ? null :
                            new PatternError(worldState.getPos(), Collections.emptyList()));
    // Allow all heating coils, and require them to have the same type.
    public static Supplier<TraceabilityPredicate> HEATING_COILS = () -> new TraceabilityPredicate(
            worldState -> GregTechAPI.HEATING_COILS.containsKey(worldState.getBlockState()) ? null :
                    PatternError.PLACEHOLDER,
            () -> GregTechAPI.HEATING_COILS.entrySet().stream()
                    // sort to make autogenerated jei previews not pick random coils each game load
                    .sorted(Comparator.comparingInt(entry -> entry.getValue().getTier()))
                    .map(entry -> new BlockInfo(entry.getKey(), null))
                    .toArray(BlockInfo[]::new),
            null)
                    .addTooltips("gregtech.multiblock.pattern.error.coils");

    public final List<SimplePredicate> simple = new ArrayList<>();
    protected boolean isCenter;
    protected boolean hasAir = false;
    protected boolean isSingle = true;

    public TraceabilityPredicate() {}

    public TraceabilityPredicate(TraceabilityPredicate predicate) {
        simple.addAll(predicate.simple);
        isCenter = predicate.isCenter;
        hasAir = predicate.hasAir;
        isSingle = predicate.isSingle;
    }

    public TraceabilityPredicate(Function<BlockWorldState, PatternError> predicate,
                                 Supplier<BlockInfo[]> candidates,
                                 Function<Map<String, String>, BlockInfo> buildFunction) {
        simple.add(new SimplePredicate(predicate, candidates, buildFunction));
    }

    public TraceabilityPredicate(Function<BlockWorldState, PatternError> predicate, Supplier<BlockInfo[]> candidates) {
        this(predicate, candidates, null);
    }

    public TraceabilityPredicate(Function<BlockWorldState, PatternError> predicate) {
        this(predicate, null, null);
    }

    /**
     * Mark it as the controller of this multi. Normally you won't call it yourself. Use
     * {@link MultiblockControllerBase#selfPredicate()} plz.
     */
    public TraceabilityPredicate setCenter() {
        isCenter = true;
        return this;
    }

    public boolean isCenter() {
        return isCenter;
    }

    public TraceabilityPredicate sort() {
        // reverse so that all min layer and global counts are at the front
        simple.sort(Collections
                .reverseOrder(Comparator.comparingInt(a -> ((a.minLayerCount + 1) * 100 + a.minGlobalCount))));
        return this;
    }

    /**
     * Add tooltips for candidates. They are shown in JEI Pages.
     * Do NOT pass {@link I18n#format(String, Object...)} calls here! Everything is will be translated when it's needed.
     * If you need parameters, use {@link #addTooltip(String, Object...)} instead.
     */
    public TraceabilityPredicate addTooltips(String... tips) {
        if (FMLCommonHandler.instance().getSide() == Side.CLIENT && tips.length > 0) {
            List<String> tooltips = Arrays.stream(tips).collect(Collectors.toList());
            simple.forEach(predicate -> {
                if (predicate.candidates == null) return;
                if (predicate.toolTips == null) {
                    predicate.toolTips = new ArrayList<>();
                }
                predicate.toolTips.addAll(tooltips);
            });
        }
        return this;
    }

    /**
     * Gets the candidates for this predicate.
     * 
     * @return A list containing lists which group together candidates
     */
    public List<List<ItemStack>> getCandidates() {
        List<List<ItemStack>> candidates = new ArrayList<>();
        for (TraceabilityPredicate.SimplePredicate pred : simple) {
            candidates.add(pred.getCandidates());
        }
        return candidates;
    }

    /**
     * Note: This method does not translate dynamically!! Parameters can not be updated once set.
     */
    public TraceabilityPredicate addTooltip(String langKey, Object... data) {
        if (FMLCommonHandler.instance().getSide() == Side.CLIENT) {
            addTooltips(I18n.format(langKey, data));
        }
        return this;
    }

    /**
     * Set the minimum number of candidate blocks.
     */
    public TraceabilityPredicate setMinGlobalLimited(int min) {
        simple.forEach(p -> p.minGlobalCount = min);
        return this;
    }

    public TraceabilityPredicate setMinGlobalLimited(int min, int previewCount) {
        return this.setMinGlobalLimited(min).setPreviewCount(previewCount);
    }

    /**
     * Set the maximum number of candidate blocks.
     */
    public TraceabilityPredicate setMaxGlobalLimited(int max) {
        simple.forEach(p -> p.maxGlobalCount = max);
        return this;
    }

    public TraceabilityPredicate setMaxGlobalLimited(int max, int previewCount) {
        return this.setMaxGlobalLimited(max).setPreviewCount(previewCount);
    }

    /**
     * Set the minimum number of candidate blocks for each aisle layer.
     */
    public TraceabilityPredicate setMinLayerLimited(int min) {
        simple.forEach(p -> p.minLayerCount = min);
        return this;
    }

    public TraceabilityPredicate setMinLayerLimited(int min, int previewCount) {
        return this.setMinLayerLimited(min).setPreviewCount(previewCount);
    }

    /**
     * Set the maximum number of candidate blocks for each aisle layer.
     */
    public TraceabilityPredicate setMaxLayerLimited(int max) {
        simple.forEach(p -> p.maxLayerCount = max);
        return this;
    }

    public TraceabilityPredicate setMaxLayerLimited(int max, int previewCount) {
        return this.setMaxLayerLimited(max).setPreviewCount(previewCount);
    }

    /**
     * Sets the Minimum and Maximum limit to the passed value
     *
     * @param limit The Maximum and Minimum limit
     */
    public TraceabilityPredicate setExactLimit(int limit) {
        return this.setMinGlobalLimited(limit).setMaxGlobalLimited(limit);
    }

    /**
     * Set the number of it appears in JEI pages. It only affects JEI preview. (The specific number)
     */
    public TraceabilityPredicate setPreviewCount(int count) {
        simple.forEach(p -> p.previewCount = count);
        return this;
    }

    public PatternError test(BlockWorldState worldState,
                             Object2IntMap<SimplePredicate> globalCache,
                             Object2IntMap<SimplePredicate> layerCache) {
        PatternError lastError = null;
        for (SimplePredicate pred : simple) {
            PatternError error = pred.testLimited(worldState, globalCache, layerCache);
            if (error == null) return null;

            lastError = error;
        }
        return lastError == PatternError.PLACEHOLDER ? new PatternError(worldState.getPos(), getCandidates()) :
                lastError;
    }

    public TraceabilityPredicate or(TraceabilityPredicate other) {
        if (other != null) {
            TraceabilityPredicate newPredicate = new TraceabilityPredicate(this);
            if (this != AIR && other != AIR) {
                newPredicate.isSingle = false;
            } else {
                newPredicate.isSingle = this.isSingle && other.isSingle;
            }
            newPredicate.hasAir = newPredicate.hasAir || this == AIR || other == AIR;
            newPredicate.simple.addAll(other.simple);
            return newPredicate;
        }
        return this;
    }

    public static class SimplePredicate {

        public final Supplier<BlockInfo[]> candidates;
        public final Function<BlockWorldState, PatternError> predicate;
        public final Function<Map<String, String>, BlockInfo> buildFunction;

        @SideOnly(Side.CLIENT)
        private List<String> toolTips;

        public int minGlobalCount = -1;
        public int maxGlobalCount = -1;
        public int minLayerCount = -1;
        public int maxLayerCount = -1;

        public int previewCount = -1;

        public SimplePredicate(Function<BlockWorldState, PatternError> predicate,
                               Supplier<BlockInfo[]> candidates,
                               @Nullable Function<Map<String, String>, BlockInfo> buildFunction) {
            this.predicate = predicate;
            this.candidates = candidates;
            this.buildFunction = buildFunction;
        }

        @SideOnly(Side.CLIENT)
        public List<String> getToolTips(TraceabilityPredicate predicates) {
            List<String> result = new ArrayList<>();
            if (toolTips != null) {
                toolTips.forEach(tip -> result.add(I18n.format(tip)));
            }
            if (minGlobalCount == maxGlobalCount && maxGlobalCount != -1) {
                result.add(I18n.format("gregtech.multiblock.pattern.error.limited_exact", minGlobalCount));
            } else if (minGlobalCount != maxGlobalCount && minGlobalCount != -1 && maxGlobalCount != -1) {
                result.add(I18n.format("gregtech.multiblock.pattern.error.limited_within", minGlobalCount,
                        maxGlobalCount));
            } else {
                if (minGlobalCount != -1) {
                    result.add(I18n.format("gregtech.multiblock.pattern.error.limited.1", minGlobalCount));
                }
                if (maxGlobalCount != -1) {
                    result.add(I18n.format("gregtech.multiblock.pattern.error.limited.0", maxGlobalCount));
                }
            }
            if (minLayerCount != -1) {
                result.add(I18n.format("gregtech.multiblock.pattern.error.limited.3", minLayerCount));
            }
            if (maxLayerCount != -1) {
                result.add(I18n.format("gregtech.multiblock.pattern.error.limited.2", maxLayerCount));
            }
            if (predicates == null) return result;
            if (predicates.isSingle) {
                result.add(I18n.format("gregtech.multiblock.pattern.single"));
            }
            if (predicates.hasAir) {
                result.add(I18n.format("gregtech.multiblock.pattern.replaceable_air"));
            }
            return result;
        }

        public PatternError testRaw(BlockWorldState worldState) {
            return predicate.apply(worldState);
        }

        public PatternError testLimited(BlockWorldState worldState,
                                        Object2IntMap<SimplePredicate> globalCache,
                                        Object2IntMap<SimplePredicate> layerCache) {
            PatternError error = testGlobal(worldState, globalCache);
            if (error != null) return error;
            return testLayer(worldState, layerCache);
        }

        public PatternError testGlobal(BlockWorldState worldState, Object2IntMap<SimplePredicate> cache) {
            PatternError result = predicate.apply(worldState);

            if ((minGlobalCount == -1 && maxGlobalCount == -1) || cache == null || result != null) return result;

            int count = cache.put(this, cache.getInt(this) + 1) + 1;
            if (maxGlobalCount == -1 || count <= maxGlobalCount) return null;

            return new SinglePredicateError(this, 0);
        }

        public PatternError testLayer(BlockWorldState worldState, Object2IntMap<SimplePredicate> cache) {
            PatternError result = predicate.apply(worldState);

            if ((minLayerCount == -1 && maxLayerCount == -1) || cache == null || result != null) return result;

            int count = cache.put(this, cache.getInt(this) + 1) + 1;
            if (maxLayerCount == -1 || count <= maxLayerCount) return null;

            return new SinglePredicateError(this, 2);
        }

        public List<ItemStack> getCandidates() {
            return candidates == null ? Collections.emptyList() : Arrays.stream(this.candidates.get())
                    .filter(info -> info.getBlockState().getBlock() != Blocks.AIR).map(info -> {
                        IBlockState blockState = info.getBlockState();
                        MetaTileEntity metaTileEntity = info.getTileEntity() instanceof IGregTechTileEntity ?
                                ((IGregTechTileEntity) info.getTileEntity()).getMetaTileEntity() : null;
                        if (metaTileEntity != null) {
                            return metaTileEntity.getStackForm();
                        } else {
                            return new ItemStack(Item.getItemFromBlock(blockState.getBlock()), 1,
                                    blockState.getBlock().damageDropped(blockState));
                        }
                    }).collect(Collectors.toList());
        }
    }

    public static class SinglePredicateError extends PatternError {

        public final int type, number;

        public SinglePredicateError(SimplePredicate failingPredicate, int type) {
            super(null, Collections.singletonList(failingPredicate.getCandidates()));
            this.type = type;

            int number = -1;
            if (type == 0) number = failingPredicate.maxGlobalCount;
            if (type == 1) number = failingPredicate.minGlobalCount;
            if (type == 2) number = failingPredicate.maxLayerCount;
            if (type == 3) number = failingPredicate.minLayerCount;

            this.number = number;
        }

        @SideOnly(Side.CLIENT)
        @Override
        public String getErrorInfo() {
            return I18n.format("gregtech.multiblock.pattern.error.limited." + type, number);
        }
    }
}
